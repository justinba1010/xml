/* setup.ml generated for the first time by OASIS v0.2.0 */

/* OASIS_START */
/* DO NOT EDIT (digest: 83d4765efc61d370c4f9bbdda5eecfb6) */
/*
    Regenerated by OASIS v0.4.10
    Visit http://oasis.forge.ocamlcore.org for more information and
    documentation about functions used in this file.
 */
module OASISGettext = {
  /* # 22 "src/oasis/OASISGettext.ml" */

  let ns_ = str => str;
  let s_ = str => str;
  let f_ = (str: format4('a, 'b, 'c, 'd)) => str;

  let fn_ = (fmt1, fmt2, n) =>
    if (n == 1) {
      fmt1 ^^ "";
    } else {
      fmt2 ^^ "";
    };

  let init = [];
};

module OASISString = {
  /* # 22 "src/oasis/OASISString.ml" */

  /** Various string utilities.

      Mostly inspired by extlib and batteries ExtString and BatString libraries.

      @author Sylvain Le Gall
  */;

  /** Various string utilities.

      Mostly inspired by extlib and batteries ExtString and BatString libraries.

      @author Sylvain Le Gall
  */

  let nsplitf = (str, f) =>
    if (str == "") {
      [];
    } else {
      let buf = Buffer.create(13);
      let lst = ref([]);
      let push = () => {
        lst := [Buffer.contents(buf), ...lst^];
        Buffer.clear(buf);
      };

      let str_len = String.length(str);
      for (i in 0 to str_len - 1) {
        if (f(str.[i])) {
          push();
        } else {
          Buffer.add_char(buf, str.[i]);
        };
      };
      push();
      List.rev(lst^);
    };

  /** [nsplit c s] Split the string [s] at char [c]. It doesn't include the
      separator.
  */

  let nsplit = (str, c) => nsplitf(str, (==)(c));

  let find = (~what, ~offset=0, str) => {
    let what_idx = ref(0);
    let str_idx = ref(offset);
    while (str_idx^ < String.length(str) && what_idx^ < String.length(what)) {
      if (str.[str_idx^] == what.[what_idx^]) {
        incr(what_idx);
      } else {
        what_idx := 0;
      };
      incr(str_idx);
    };
    if (what_idx^ != String.length(what)) {
      raise(Not_found);
    } else {
      str_idx^ - what_idx^;
    };
  };

  let sub_start = (str, len) => {
    let str_len = String.length(str);
    if (len >= str_len) {
      "";
    } else {
      String.sub(str, len, str_len - len);
    };
  };

  let sub_end = (~offset=0, str, len) => {
    let str_len = String.length(str);
    if (len >= str_len) {
      "";
    } else {
      String.sub(str, 0, str_len - len);
    };
  };

  let starts_with = (~what, ~offset=0, str) => {
    let what_idx = ref(0);
    let str_idx = ref(offset);
    let ok = ref(true);
    while (ok^
           && str_idx^ < String.length(str)
           && what_idx^ < String.length(what)) {
      if (str.[str_idx^] == what.[what_idx^]) {
        incr(what_idx);
      } else {
        ok := false;
      };
      incr(str_idx);
    };
    what_idx^ == String.length(what);
  };

  let strip_starts_with = (~what, str) =>
    if (starts_with(~what, str)) {
      sub_start(str, String.length(what));
    } else {
      raise(Not_found);
    };

  let ends_with = (~what, ~offset=0, str) => {
    let what_idx = ref(String.length(what) - 1);
    let str_idx = ref(String.length(str) - 1);
    let ok = ref(true);
    while (ok^ && offset <= str_idx^ && 0 <= what_idx^) {
      if (str.[str_idx^] == what.[what_idx^]) {
        decr(what_idx);
      } else {
        ok := false;
      };
      decr(str_idx);
    };
    what_idx^ == (-1);
  };

  let strip_ends_with = (~what, str) =>
    if (ends_with(~what, str)) {
      sub_end(str, String.length(what));
    } else {
      raise(Not_found);
    };

  let replace_chars = (f, s) => {
    let buf = Buffer.create(String.length(s));
    String.iter(c => Buffer.add_char(buf, f(c)), s);
    Buffer.contents(buf);
  };

  let lowercase_ascii =
    replace_chars(c =>
      if (c >= 'A' && c <= 'Z') {
        Char.chr(Char.code(c) + 32);
      } else {
        c;
      }
    );

  let uncapitalize_ascii = s =>
    if (s != "") {
      lowercase_ascii(String.sub(s, 0, 1))
      ++ String.sub(s, 1, String.length(s) - 1);
    } else {
      s;
    };

  let uppercase_ascii =
    replace_chars(c =>
      if (c >= 'a' && c <= 'z') {
        Char.chr(Char.code(c) - 32);
      } else {
        c;
      }
    );

  let capitalize_ascii = s =>
    if (s != "") {
      uppercase_ascii(String.sub(s, 0, 1))
      ++ String.sub(s, 1, String.length(s) - 1);
    } else {
      s;
    };
};

module OASISUtils = {
  /* # 22 "src/oasis/OASISUtils.ml" */

  open OASISGettext;

  module MapExt = {
    module type S = {
      include Map.S;
      let add_list: (t('a), list((key, 'a))) => t('a);
      let of_list: list((key, 'a)) => t('a);
      let to_list: t('a) => list((key, 'a));
    };

    module Make = (Ord: Map.OrderedType) => {
      include Map.Make(Ord);

      let rec add_list = t =>
        fun
        | [(k, v), ...tl] => add_list(add(k, v, t), tl)
        | [] => t;

      let of_list = lst => add_list(empty, lst);

      let to_list = t => fold((k, v, acc) => [(k, v), ...acc], t, []);
    };
  };

  module MapString = MapExt.Make(String);

  module SetExt = {
    module type S = {
      include Set.S;
      let add_list: (t, list(elt)) => t;
      let of_list: list(elt) => t;
      let to_list: t => list(elt);
    };

    module Make = (Ord: Set.OrderedType) => {
      include Set.Make(Ord);

      let rec add_list = t =>
        fun
        | [e, ...tl] => add_list(add(e, t), tl)
        | [] => t;

      let of_list = lst => add_list(empty, lst);

      let to_list = elements;
    };
  };

  module SetString = SetExt.Make(String);

  let compare_csl = (s1, s2) =>
    String.compare(
      OASISString.lowercase_ascii(s1),
      OASISString.lowercase_ascii(s2),
    );

  module HashStringCsl =
    Hashtbl.Make({
      type t = string;
      let equal = (s1, s2) => compare_csl(s1, s2) == 0;
      let hash = s => Hashtbl.hash(OASISString.lowercase_ascii(s));
    });

  module SetStringCsl =
    SetExt.Make({
      type t = string;
      let compare = compare_csl;
    });

  let varname_of_string = (~hyphen='_', s) =>
    if (String.length(s) == 0) {
      invalid_arg("varname_of_string");
    } else {
      let buf =
        OASISString.replace_chars(
          c =>
            if ('a' <= c
                && c <= 'z'
                || 'A' <= c
                && c <= 'Z'
                || '0' <= c
                && c <= '9') {
              c;
            } else {
              hyphen;
            },
          s,
        );

      let buf =
        /* Start with a _ if digit */
        if ('0' <= s.[0] && s.[0] <= '9') {
          "_" ++ buf;
        } else {
          buf;
        };

      OASISString.lowercase_ascii(buf);
    };

  let varname_concat = (~hyphen='_', p, s) => {
    let what = String.make(1, hyphen);
    let p =
      try (OASISString.strip_ends_with(~what, p)) {
      | Not_found => p
      };

    let s =
      try (OASISString.strip_starts_with(~what, s)) {
      | Not_found => s
      };

    p ++ what ++ s;
  };

  let is_varname = str => str == varname_of_string(str);

  let failwithf = fmt => Printf.ksprintf(failwith, fmt);

  let rec file_location = (~pos1=?, ~pos2=?, ~lexbuf=?, ()) =>
    switch (pos1, pos2, lexbuf) {
    | (Some(p), None, _)
    | (None, Some(p), _) => file_location(~pos1=p, ~pos2=p, ~lexbuf?, ())
    | (Some(p1), Some(p2), _) =>
      open Lexing;
      let (fn, lineno) = (p1.pos_fname, p1.pos_lnum);
      let c1 = p1.pos_cnum - p1.pos_bol;
      let c2 = c1 + (p2.pos_cnum - p1.pos_cnum);
      Printf.sprintf(
        f_("file %S, line %d, characters %d-%d"),
        fn,
        lineno,
        c1,
        c2,
      );
    | (_, _, Some(lexbuf)) =>
      file_location(
        ~pos1=Lexing.lexeme_start_p(lexbuf),
        ~pos2=Lexing.lexeme_end_p(lexbuf),
        (),
      )
    | (None, None, None) => s_("<position undefined>")
    };

  let failwithpf = (~pos1=?, ~pos2=?, ~lexbuf=?, fmt) => {
    let loc = file_location(~pos1?, ~pos2?, ~lexbuf?, ());
    Printf.ksprintf(s => failwith(Printf.sprintf("%s: %s", loc, s)), fmt);
  };
};

module OASISUnixPath = {
  /* # 22 "src/oasis/OASISUnixPath.ml" */

  type unix_filename = string;
  type unix_dirname = string;

  type host_filename = string;
  type host_dirname = string;

  let current_dir_name = ".";

  let parent_dir_name = "..";

  let is_current_dir = fn => fn == current_dir_name || fn == "";

  let concat = (f1, f2) =>
    if (is_current_dir(f1)) {
      f2;
    } else {
      let f1' =
        try (OASISString.strip_ends_with(~what="/", f1)) {
        | Not_found => f1
        };

      f1' ++ "/" ++ f2;
    };

  let make =
    fun
    | [hd, ...tl] => List.fold_left((f, p) => concat(f, p), hd, tl)
    | [] => invalid_arg("OASISUnixPath.make");

  let dirname = f =>
    try (String.sub(f, 0, String.rindex(f, '/'))) {
    | Not_found => current_dir_name
    };

  let basename = f =>
    try (
      {
        let pos_start = String.rindex(f, '/') + 1;

        String.sub(f, pos_start, String.length(f) - pos_start);
      }
    ) {
    | Not_found => f
    };

  let chop_extension = f =>
    try (
      {
        let last_dot = String.rindex(f, '.');

        let sub = String.sub(f, 0, last_dot);

        try (
          {
            let last_slash = String.rindex(f, '/');

            if (last_slash < last_dot) {
              sub;
            } else {
              f;
            };
          }
        ) {
        | Not_found => sub
        };
      }
    ) {
    | Not_found => f
    };

  let capitalize_file = f => {
    let dir = dirname(f);
    let base = basename(f);
    concat(dir, OASISString.capitalize_ascii(base));
  };

  let uncapitalize_file = f => {
    let dir = dirname(f);
    let base = basename(f);
    concat(dir, OASISString.uncapitalize_ascii(base));
  };
};

module OASISHostPath = {
  /* # 22 "src/oasis/OASISHostPath.ml" */

  open Filename;
  open OASISGettext;

  module Unix = OASISUnixPath;

  let make =
    fun
    | [] => invalid_arg("OASISHostPath.make")
    | [hd, ...tl] => List.fold_left(Filename.concat, hd, tl);

  let of_unix = ufn =>
    switch (Sys.os_type) {
    | "Unix"
    | "Cygwin" => ufn
    | "Win32" =>
      make(
        List.map(
          p =>
            if (p == Unix.current_dir_name) {
              current_dir_name;
            } else if (p == Unix.parent_dir_name) {
              parent_dir_name;
            } else {
              p;
            },
          OASISString.nsplit(ufn, '/'),
        ),
      )
    | os_type =>
      OASISUtils.failwithf(
        f_(
          "Don't know the path format of os_type %S when translating unix filename. %S",
        ),
        os_type,
        ufn,
      )
    };
};

module OASISFileSystem = {
  /* # 22 "src/oasis/OASISFileSystem.ml" */

  /** File System functions

      @author Sylvain Le Gall
  */;

  type filename('a) = string;

  class type closer = {
    pub close: unit;
  };

  class type reader = {
    inherit closer;
    pub input: (Buffer.t, int) => unit;
  };

  class type writer = {
    inherit closer;
    pub output: Buffer.t => unit;
  };

  class type fs ('a) = {
    pub string_of_filename: filename('a) => string;
    pub open_out:
      (~mode: list(open_flag)=?, ~perm: int=?, filename('a)) => writer;
    pub open_in:
      (~mode: list(open_flag)=?, ~perm: int=?, filename('a)) => reader;
    pub file_exists: filename('a) => bool;
    pub remove: filename('a) => unit;
  };

  module Mode = {
    let default_in = [Open_rdonly];
    let default_out = [Open_wronly, Open_creat, Open_trunc];

    let text_in = [Open_text, ...default_in];
    let text_out = [Open_text, ...default_out];

    let binary_in = [Open_binary, ...default_in];
    let binary_out = [Open_binary, ...default_out];
  };

  let std_length = 4096; /* Standard buffer/read length. */
  let binary_out = Mode.binary_out;
  let binary_in = Mode.binary_in;

  let of_unix_filename = ufn: filename('a) => ufn;
  let to_unix_filename = fn: string => fn;

  let defer_close = (o, f) =>
    try (
      {
        let r = f(o);
        o#close;
        r;
      }
    ) {
    | e =>
      o#close;
      raise(e);
    };

  let stream_of_reader = rdr => {
    let buf = Buffer.create(std_length);
    let pos = ref(0);
    let eof = ref(false);
    let rec next = idx => {
      let bpos = idx - pos^;
      if (eof^) {
        None;
      } else if (bpos < Buffer.length(buf)) {
        Some(Buffer.nth(buf, bpos));
      } else {
        pos := pos^ + Buffer.length(buf);
        Buffer.clear(buf);
        try (rdr#input(buf, std_length)) {
        | End_of_file =>
          if (Buffer.length(buf) == 0) {
            eof := true;
          }
        };
        next(idx);
      };
    };

    Stream.from(next);
  };

  let read_all = (buf, rdr) =>
    try (
      while (true) {
        rdr#input(buf, std_length);
      }
    ) {
    | End_of_file => ()
    };

  class host_fs ('a) (rootdir) : fs('a) = {
    as self;
    pri host_filename = fn => Filename.concat(rootdir, fn);
    pub string_of_filename = self#host_filename;
    pub open_out = (~mode=Mode.text_out, ~perm=438, fn) => {
      let chn = open_out_gen(mode, perm, self#host_filename(fn));
      {
        as _;
        pub close = close_out(chn);
        pub output = buf => Buffer.output_buffer(chn, buf)
      };
    };
    pub open_in = (~mode=Mode.text_in, ~perm=438, fn) => {
      /* TODO: use Buffer.add_channel when minimal version of OCaml will
       * be >= 4.03.0 (previous version was discarding last chars).
       */
      let chn = open_in_gen(mode, perm, self#host_filename(fn));
      let strm = Stream.of_channel(chn);
      {
        as _;
        pub close = close_in(chn);
        pub input = (buf, len) => {
          let read = ref(0);
          try (
            for (_i in 0 to len) {
              Buffer.add_char(buf, Stream.next(strm));
              incr(read);
            }
          ) {
          | Stream.Failure =>
            if (read^ == 0) {
              raise(End_of_file);
            }
          };
        }
      };
    };
    pub file_exists = fn => Sys.file_exists(self#host_filename(fn));
    pub remove = fn => Sys.remove(self#host_filename(fn));
  };
};

module OASISContext = {
  /* # 22 "src/oasis/OASISContext.ml" */

  open OASISGettext;

  type level = [ | `Debug | `Info | `Warning | `Error];

  type source;
  type source_filename = OASISFileSystem.filename(source);

  let in_srcdir = ufn => OASISFileSystem.of_unix_filename(ufn);

  type t = {
    /* TODO: replace this by a proplist. */
    quiet: bool,
    info: bool,
    debug: bool,
    ignore_plugins: bool,
    ignore_unknown_fields: bool,
    printf: (level, string) => unit,
    srcfs: OASISFileSystem.fs(source),
    load_oasis_plugin: string => bool,
  };

  let printf = (lvl, str) => {
    let beg =
      switch (lvl) {
      | `Error => s_("E: ")
      | `Warning => s_("W: ")
      | `Info => s_("I: ")
      | `Debug => s_("D: ")
      };

    prerr_endline(beg ++ str);
  };

  let default =
    ref({
      quiet: false,
      info: false,
      debug: false,
      ignore_plugins: false,
      ignore_unknown_fields: false,
      printf,
      srcfs: (new OASISFileSystem.host_fs)(Sys.getcwd()),
      load_oasis_plugin: _ => false,
    });

  let quiet = {...default^, quiet: true};

  let fspecs = () => {
    /* TODO: don't act on default. */
    let ignore_plugins = ref(false);
    (
      [
        (
          "-quiet",
          Arg.Unit(() => default := {...default^, quiet: true}),
          s_(" Run quietly"),
        ),
        (
          "-info",
          Arg.Unit(() => default := {...default^, info: true}),
          s_(" Display information message"),
        ),
        (
          "-debug",
          Arg.Unit(() => default := {...default^, debug: true}),
          s_(" Output debug message"),
        ),
        (
          "-ignore-plugins",
          Arg.Set(ignore_plugins),
          s_(" Ignore plugin's field."),
        ),
        (
          "-C",
          Arg.String(
            str => {
              Sys.chdir(str);
              default :=
                {...default^, srcfs: (new OASISFileSystem.host_fs)(str)};
            },
          ),
          s_(
            "dir Change directory before running (affects setup.{data,log}).",
          ),
        ),
      ],
      () => {...default^, ignore_plugins: ignore_plugins^},
    );
  };
};

module PropList = {
  /* # 22 "src/oasis/PropList.ml" */

  open OASISGettext;

  type name = string;

  exception Not_set(name, option(string));
  exception No_printer(name);
  exception Unknown_field(name, name);

  let () =
    Printexc.register_printer(
      fun
      | [@implicit_arity] Not_set(nm, Some(rsn)) =>
        Some(Printf.sprintf(f_("Field '%s' is not set: %s"), nm, rsn))
      | [@implicit_arity] Not_set(nm, None) =>
        Some(Printf.sprintf(f_("Field '%s' is not set"), nm))
      | No_printer(nm) =>
        Some(Printf.sprintf(f_("No default printer for value %s"), nm))
      | [@implicit_arity] Unknown_field(nm, schm) =>
        Some(
          Printf.sprintf(
            f_("Field %s is not defined in schema %s"),
            nm,
            schm,
          ),
        )
      | _ => None,
    );

  module Data = {
    type t = Hashtbl.t(name, unit => unit);

    let create = () => Hashtbl.create(13);

    let clear = t => Hashtbl.clear(t);
    /* # 77 "src/oasis/PropList.ml" */
  };

  module Schema = {
    type value('ctxt, 'extra) = {
      get: Data.t => string,
      set: (Data.t, ~context: 'ctxt=?, string) => unit,
      help: option(unit => string),
      extra: 'extra,
    };

    type t('ctxt, 'extra) = {
      name,
      fields: Hashtbl.t(name, value('ctxt, 'extra)),
      order: Queue.t(name),
      name_norm: string => string,
    };

    let create = (~case_insensitive=false, nm) => {
      name: nm,
      fields: Hashtbl.create(13),
      order: Queue.create(),
      name_norm:
        if (case_insensitive) {
          OASISString.lowercase_ascii;
        } else {
          s => s;
        },
    };

    let add = (t, nm, set, get, extra, help) => {
      let key = t.name_norm(nm);

      if (Hashtbl.mem(t.fields, key)) {
        failwith(
          Printf.sprintf(
            f_("Field '%s' is already defined in schema '%s'"),
            nm,
            t.name,
          ),
        );
      };
      Hashtbl.add(t.fields, key, {set, get, help, extra});
      Queue.add(nm, t.order);
    };

    let mem = (t, nm) => Hashtbl.mem(t.fields, nm);

    let find = (t, nm) =>
      try (Hashtbl.find(t.fields, t.name_norm(nm))) {
      | Not_found => raise([@implicit_arity] Unknown_field(nm, t.name))
      };

    let get = (t, data, nm) => find(t, nm).get(data);

    let set = (t, data, nm, ~context=?, x) =>
      find(t, nm).set(data, ~context?, x);

    let fold = (f, acc, t) =>
      Queue.fold(
        (acc, k) => {
          let v = find(t, k);

          f(acc, k, v.extra, v.help);
        },
        acc,
        t.order,
      );

    let iter = (f, t) => fold(() => f, (), t);

    let name = t => t.name;
  };

  module Field = {
    type t('ctxt, 'value, 'extra) = {
      set: (Data.t, ~context: 'ctxt=?, 'value) => unit,
      get: Data.t => 'value,
      sets: (Data.t, ~context: 'ctxt=?, string) => unit,
      gets: Data.t => string,
      help: option(unit => string),
      extra: 'extra,
    };

    let new_id = {
      let last_id = ref(0);

      () => {
        incr(last_id);
        last_id^;
      };
    };

    let create =
        (
          ~schema=?,
          ~name=?,
          ~parse=?,
          ~print=?,
          ~default=?,
          ~update=?,
          ~help=?,
          extra,
        ) => {
      /* Default value container */
      let v = ref(None);

      /* If name is not given, create unique one */
      let nm =
        switch (name) {
        | Some(s) => s
        | None => Printf.sprintf("_anon_%d", new_id())
        };

      /* Last chance to get a value: the default */
      let default = () =>
        switch (default) {
        | Some(d) => d
        | None =>
          raise(
            [@implicit_arity] Not_set(nm, Some(s_("no default value"))),
          )
        };

      /* Get data */
      let get = data =>
        /* Get value */
        try (
          {
            (Hashtbl.find(data, nm))();
            switch (v^) {
            | Some(x) => x
            | None => default()
            };
          }
        ) {
        | Not_found => default()
        };

      /* Set data */
      let set = (data, ~context=?, x) => {
        let x =
          switch (update) {
          | Some(f) =>
            try (f(~context?, get(data), x)) {
            | Not_set(_) => x
            }
          | None => x
          };

        Hashtbl.replace(data, nm, () => v := Some(x));
      };

      /* Parse string value, if possible */
      let parse =
        switch (parse) {
        | Some(f) => f
        | None => (
            (~context=?, s) =>
              failwith(
                Printf.sprintf(
                  f_("Cannot parse field '%s' when setting value %S"),
                  nm,
                  s,
                ),
              )
          )
        };

      /* Set data, from string */
      let sets = (data, ~context=?, s) =>
        set(~context?, data, parse(~context?, s));

      /* Output value as string, if possible */
      let print =
        switch (print) {
        | Some(f) => f
        | None => (_ => raise(No_printer(nm)))
        };

      /* Get data, as a string */
      let gets = data => print(get(data));

      switch (schema) {
      | Some(t) => Schema.add(t, nm, sets, gets, extra, help)
      | None => ()
      };

      {set, get, sets, gets, help, extra};
    };

    let fset = (data, t, ~context=?, x) => t.set(data, ~context?, x);

    let fget = (data, t) => t.get(data);

    let fsets = (data, t, ~context=?, s) => t.sets(data, ~context?, s);

    let fgets = (data, t) => t.gets(data);
  };

  module FieldRO = {
    let create =
        (
          ~schema=?,
          ~name=?,
          ~parse=?,
          ~print=?,
          ~default=?,
          ~update=?,
          ~help=?,
          extra,
        ) => {
      let fld =
        Field.create(
          ~schema?,
          ~name?,
          ~parse?,
          ~print?,
          ~default?,
          ~update?,
          ~help?,
          extra,
        );

      data => Field.fget(data, fld);
    };
  };
};

module OASISMessage = {
  /* # 22 "src/oasis/OASISMessage.ml" */

  open OASISGettext;
  open OASISContext;

  let generic_message = (~ctxt, lvl, fmt) => {
    let cond =
      if (ctxt.quiet) {
        false;
      } else {
        switch (lvl) {
        | `Debug => ctxt.debug
        | `Info => ctxt.info
        | _ => true
        };
      };

    Printf.ksprintf(
      str =>
        if (cond) {
          ctxt.printf(lvl, str);
        },
      fmt,
    );
  };

  let debug = (~ctxt, fmt) => generic_message(~ctxt, `Debug, fmt);

  let info = (~ctxt, fmt) => generic_message(~ctxt, `Info, fmt);

  let warning = (~ctxt, fmt) => generic_message(~ctxt, `Warning, fmt);

  let error = (~ctxt, fmt) => generic_message(~ctxt, `Error, fmt);
};

module OASISVersion = {
  /* # 22 "src/oasis/OASISVersion.ml" */

  open OASISGettext;

  type t = string;

  type comparator =
    | VGreater(t)
    | VGreaterEqual(t)
    | VEqual(t)
    | VLesser(t)
    | VLesserEqual(t)
    | VOr(comparator, comparator)
    | VAnd(comparator, comparator);

  /* Range of allowed characters */
  let is_digit = c => '0' <= c && c <= '9';
  let is_alpha = c => 'a' <= c && c <= 'z' || 'A' <= c && c <= 'Z';
  let is_special =
    fun
    | '.'
    | '+'
    | '-'
    | '~' => true
    | _ => false;

  let rec version_compare = (v1, v2) =>
    if (v1 != "" || v2 != "") {
      /* Compare ascii string, using special meaning for version
        * related char
       */
      let val_ascii = c =>
        if (c == '~') {
          (-1);
        } else if (is_digit(c)) {
          0;
        } else if (c == '\000') {
          0;
        } else if (is_alpha(c)) {
          Char.code(c);
        } else {
          Char.code(c) + 256;
        };

      let len1 = String.length(v1);
      let len2 = String.length(v2);

      let p = ref(0);

      /*** Compare ascii part */
      let compare_vascii = () => {
        let cmp = ref(0);
        while (cmp^ == 0
               && p^ < len1
               && p^ < len2
               && !(is_digit(v1.[p^]) && is_digit(v2.[p^]))) {
          cmp := val_ascii(v1.[p^]) - val_ascii(v2.[p^]);
          incr(p);
        };
        if (cmp^ == 0 && p^ < len1 && p^ == len2) {
          val_ascii(v1.[p^]);
        } else if (cmp^ == 0 && p^ == len1 && p^ < len2) {
          - val_ascii(v2.[p^]);
        } else {
          cmp^;
        };
      };

      /*** Compare digit part */
      let compare_digit = () => {
        let extract_int = (v, p) => {
          let start_p = p^;
          while (p^ < String.length(v) && is_digit(v.[p^])) {
            incr(p);
          };
          let substr = String.sub(v, p^, String.length(v) - p^);

          let res =
            switch (String.sub(v, start_p, p^ - start_p)) {
            | "" => 0
            | s => int_of_string(s)
            };

          (res, substr);
        };

        let (i1, tl1) = extract_int(v1, ref(p^));
        let (i2, tl2) = extract_int(v2, ref(p^));
        (i1 - i2, tl1, tl2);
      };

      switch (compare_vascii()) {
      | 0 =>
        switch (compare_digit()) {
        | (0, tl1, tl2) =>
          if (tl1 != "" && is_digit(tl1.[0])) {
            1;
          } else if (tl2 != "" && is_digit(tl2.[0])) {
            (-1);
          } else {
            version_compare(tl1, tl2);
          }
        | (n, _, _) => n
        }
      | n => n
      };
    } else {
      0;
    };

  let version_of_string = str => str;

  let string_of_version = t => t;

  let chop = t =>
    try (
      {
        let pos = String.rindex(t, '.');

        String.sub(t, 0, pos);
      }
    ) {
    | Not_found => t
    };

  let rec comparator_apply = (v, op) =>
    switch (op) {
    | VGreater(cv) => version_compare(v, cv) > 0
    | VGreaterEqual(cv) => version_compare(v, cv) >= 0
    | VLesser(cv) => version_compare(v, cv) < 0
    | VLesserEqual(cv) => version_compare(v, cv) <= 0
    | VEqual(cv) => version_compare(v, cv) == 0
    | [@implicit_arity] VOr(op1, op2) =>
      comparator_apply(v, op1) || comparator_apply(v, op2)
    | [@implicit_arity] VAnd(op1, op2) =>
      comparator_apply(v, op1) && comparator_apply(v, op2)
    };

  let rec string_of_comparator =
    fun
    | VGreater(v) => "> " ++ string_of_version(v)
    | VEqual(v) => "= " ++ string_of_version(v)
    | VLesser(v) => "< " ++ string_of_version(v)
    | VGreaterEqual(v) => ">= " ++ string_of_version(v)
    | VLesserEqual(v) => "<= " ++ string_of_version(v)
    | [@implicit_arity] VOr(c1, c2) =>
      string_of_comparator(c1) ++ " || " ++ string_of_comparator(c2)
    | [@implicit_arity] VAnd(c1, c2) =>
      string_of_comparator(c1) ++ " && " ++ string_of_comparator(c2);

  let rec varname_of_comparator = {
    let concat = (p, v) =>
      OASISUtils.varname_concat(
        p,
        OASISUtils.varname_of_string(string_of_version(v)),
      );

    fun
    | VGreater(v) => concat("gt", v)
    | VLesser(v) => concat("lt", v)
    | VEqual(v) => concat("eq", v)
    | VGreaterEqual(v) => concat("ge", v)
    | VLesserEqual(v) => concat("le", v)
    | [@implicit_arity] VOr(c1, c2) =>
      varname_of_comparator(c1) ++ "_or_" ++ varname_of_comparator(c2)
    | [@implicit_arity] VAnd(c1, c2) =>
      varname_of_comparator(c1) ++ "_and_" ++ varname_of_comparator(c2);
  };
};

module OASISLicense = {
  /* # 22 "src/oasis/OASISLicense.ml" */

  /** License for _oasis fields
      @author Sylvain Le Gall
  */;

  type license = string;
  type license_exception = string;

  type license_version =
    | Version(OASISVersion.t)
    | VersionOrLater(OASISVersion.t)
    | NoVersion;

  type license_dep_5_unit = {
    license,
    excption: option(license_exception),
    version: license_version,
  };

  type license_dep_5 =
    | DEP5Unit(license_dep_5_unit)
    | DEP5Or(list(license_dep_5))
    | DEP5And(list(license_dep_5));

  type t =
    | DEP5License(license_dep_5)
    | OtherLicense(string); /* URL */
};

module OASISExpr = {
  /* # 22 "src/oasis/OASISExpr.ml" */

  open OASISGettext;
  open OASISUtils;

  type test = string;
  type flag = string;

  type t =
    | EBool(bool)
    | ENot(t)
    | EAnd(t, t)
    | EOr(t, t)
    | EFlag(flag)
    | ETest(test, string);

  type choices('a) = list((t, 'a));

  let eval = (var_get, t) => {
    let rec eval' =
      fun
      | EBool(b) => b

      | ENot(e) => !eval'(e)

      | [@implicit_arity] EAnd(e1, e2) => eval'(e1) && eval'(e2)

      | [@implicit_arity] EOr(e1, e2) => eval'(e1) || eval'(e2)

      | EFlag(nm) => {
          let v = var_get(nm);

          assert(v == "true" || v == "false");
          v == "true";
        }

      | [@implicit_arity] ETest(nm, vl) => {
          let v = var_get(nm);

          v == vl;
        };

    eval'(t);
  };

  let choose = (~printer=?, ~name=?, var_get, lst) => {
    let rec choose_aux =
      fun
      | [(cond, vl), ...tl] =>
        if (eval(var_get, cond)) {
          vl;
        } else {
          choose_aux(tl);
        }
      | [] => {
          let str_lst =
            if (lst == []) {
              s_("<empty>");
            } else {
              String.concat(
                s_(", "),
                List.map(
                  ((cond, vl)) =>
                    switch (printer) {
                    | Some(p) => p(vl)
                    | None => s_("<no printer>")
                    },
                  lst,
                ),
              );
            };

          switch (name) {
          | Some(nm) =>
            failwith(
              Printf.sprintf(
                f_("No result for the choice list '%s': %s"),
                nm,
                str_lst,
              ),
            )
          | None =>
            failwith(
              Printf.sprintf(f_("No result for a choice list: %s"), str_lst),
            )
          };
        };

    choose_aux(List.rev(lst));
  };
};

module OASISText = {
  /* # 22 "src/oasis/OASISText.ml" */

  type elt =
    | Para(string)
    | Verbatim(string)
    | BlankLine;

  type t = list(elt);
};

module OASISSourcePatterns = {
  /* # 22 "src/oasis/OASISSourcePatterns.ml" */

  open OASISUtils;
  open OASISGettext;

  module Templater = {
    /* TODO: use this module in BaseEnv.var_expand and BaseFileAB, at least. */
    type t = {
      atoms: list(atom),
      origin: string,
    }
    and atom =
      | Text(string)
      | Expr(expr)
    and expr =
      | Ident(string)
      | String(string)
      | Call(string, expr);

    type env = {
      variables: MapString.t(string),
      functions: MapString.t(string => string),
    };

    let eval = (env, t) => {
      let rec eval_expr = env =>
        fun
        | String(str) => str
        | Ident(nm) =>
          try (MapString.find(nm, env.variables)) {
          | Not_found =>
            /* TODO: add error location within the string. */
            failwithf(
              f_("Unable to find variable %S in source pattern %S"),
              nm,
              t.origin,
            )
          }

        | [@implicit_arity] Call(fn, expr) =>
          try ((MapString.find(fn, env.functions))(eval_expr(env, expr))) {
          | Not_found =>
            /* TODO: add error location within the string. */
            failwithf(
              f_("Unable to find function %S in source pattern %S"),
              fn,
              t.origin,
            )
          };

      String.concat(
        "",
        List.map(
          fun
          | Text(str) => str
          | Expr(expr) => eval_expr(env, expr),
          t.atoms,
        ),
      );
    };

    let parse = (env, s) => {
      let lxr = Genlex.make_lexer([]);
      let parse_expr = s => {
        let st = lxr(Stream.of_string(s));
        switch (Stream.npeek(3, st)) {
        | [Genlex.Ident(fn), Genlex.Ident(nm)] =>
          [@implicit_arity] Call(fn, Ident(nm))
        | [Genlex.Ident(fn), Genlex.String(str)] =>
          [@implicit_arity] Call(fn, String(str))
        | [Genlex.String(str)] => String(str)
        | [Genlex.Ident(nm)] => Ident(nm)
        /* TODO: add error location within the string. */
        | _ => failwithf(f_("Unable to parse expression %S"), s)
        };
      };

      let parse = s => {
        let lst_exprs = ref([]);
        let ss = {
          let buff = Buffer.create(String.length(s));
          Buffer.add_substitute(
            buff,
            s => {
              lst_exprs := [parse_expr(s), ...lst_exprs^];
              "\000";
            },
            s,
          );
          Buffer.contents(buff);
        };

        let rec join =
          fun
          | ([hd1, ...tl1], [hd2, ...tl2]) => [
              Text(hd1),
              Expr(hd2),
              ...join((tl1, tl2)),
            ]
          | ([], tl) => List.map(e => Expr(e), tl)
          | (tl, []) => List.map(e => Text(e), tl);

        join((OASISString.nsplit(ss, '\000'), List.rev(lst_exprs^)));
      };

      let t = {atoms: parse(s), origin: s};
      /* We rely on a simple evaluation for checking variables/functions.
            It works because there is no if/loop statement.
         */
      let _s: string = eval(env, t);
      t;
    };
    /* # 144 "src/oasis/OASISSourcePatterns.ml" */
  };

  type t = Templater.t;

  let env = (~modul, ()) => {
    Templater.variables: MapString.of_list([("module", modul)]),
    functions:
      MapString.of_list([
        ("capitalize_file", OASISUnixPath.capitalize_file),
        ("uncapitalize_file", OASISUnixPath.uncapitalize_file),
      ]),
  };

  let all_possible_files = (lst, ~path, ~modul) => {
    let eval = Templater.eval(env(~modul, ()));
    List.fold_left(
      (acc, pat) => [OASISUnixPath.concat(path, eval(pat)), ...acc],
      [],
      lst,
    );
  };

  let to_string = t => t.Templater.origin;
};

module OASISTypes = {
  /* # 22 "src/oasis/OASISTypes.ml" */

  type name = string;
  type package_name = string;
  type url = string;
  type unix_dirname = string;
  type unix_filename = string; /* TODO: replace everywhere. */
  type host_dirname = string; /* TODO: replace everywhere. */
  type host_filename = string; /* TODO: replace everywhere. */
  type prog = string;
  type arg = string;
  type args = list(string);
  type command_line = (prog, list(arg));

  type findlib_name = string;
  type findlib_full = string;

  type compiled_object =
    | Byte
    | Native
    | Best;

  type dependency =
    | FindlibPackage(findlib_full, option(OASISVersion.comparator))
    | InternalLibrary(name);

  type tool =
    | ExternalTool(name)
    | InternalExecutable(name);

  type vcs =
    | Darcs
    | Git
    | Svn
    | Cvs
    | Hg
    | Bzr
    | Arch
    | Monotone
    | OtherVCS(url);

  type plugin_kind = [
    | `Configure
    | `Build
    | `Doc
    | `Test
    | `Install
    | `Extra
  ];

  type plugin_data_purpose = [
    | `Configure
    | `Build
    | `Install
    | `Clean
    | `Distclean
    | `Install
    | `Uninstall
    | `Test
    | `Doc
    | `Extra
    | `Other(string)
  ];

  type plugin('a) = ('a, name, option(OASISVersion.t));

  type all_plugin = plugin(plugin_kind);

  type plugin_data = list((all_plugin, plugin_data_purpose, unit => unit));

  type conditional('a) = OASISExpr.choices('a);

  type custom = {
    pre_command: conditional(option(command_line)),
    post_command: conditional(option(command_line)),
  };

  type common_section = {
    cs_name: name,
    cs_data: PropList.Data.t,
    cs_plugin_data: plugin_data,
  };

  type build_section = {
    bs_build: conditional(bool),
    bs_install: conditional(bool),
    bs_path: unix_dirname,
    bs_compiled_object: compiled_object,
    bs_build_depends: list(dependency),
    bs_build_tools: list(tool),
    bs_interface_patterns: list(OASISSourcePatterns.t),
    bs_implementation_patterns: list(OASISSourcePatterns.t),
    bs_c_sources: list(unix_filename),
    bs_data_files: list((unix_filename, option(unix_filename))),
    bs_findlib_extra_files: list(unix_filename),
    bs_ccopt: conditional(args),
    bs_cclib: conditional(args),
    bs_dlllib: conditional(args),
    bs_dllpath: conditional(args),
    bs_byteopt: conditional(args),
    bs_nativeopt: conditional(args),
  };

  type library = {
    lib_modules: list(string),
    lib_pack: bool,
    lib_internal_modules: list(string),
    lib_findlib_parent: option(findlib_name),
    lib_findlib_name: option(findlib_name),
    lib_findlib_directory: option(unix_dirname),
    lib_findlib_containers: list(findlib_name),
  };

  type object_ = {
    obj_modules: list(string),
    obj_findlib_fullname: option(list(findlib_name)),
    obj_findlib_directory: option(unix_dirname),
  };

  type executable = {
    exec_custom: bool,
    exec_main_is: unix_filename,
  };

  type flag = {
    flag_description: option(string),
    flag_default: conditional(bool),
  };

  type source_repository = {
    src_repo_type: vcs,
    src_repo_location: url,
    src_repo_browser: option(url),
    src_repo_module: option(string),
    src_repo_branch: option(string),
    src_repo_tag: option(string),
    src_repo_subdir: option(unix_filename),
  };

  type test = {
    test_type: plugin([ | `Test]),
    test_command: conditional(command_line),
    test_custom: custom,
    test_working_directory: option(unix_filename),
    test_run: conditional(bool),
    test_tools: list(tool),
  };

  type doc_format =
    | HTML(unix_filename) /* TODO: source filename. */
    | DocText
    | PDF
    | PostScript
    | Info(unix_filename) /* TODO: source filename. */
    | DVI
    | OtherDoc;

  type doc = {
    doc_type: plugin([ | `Doc]),
    doc_custom: custom,
    doc_build: conditional(bool),
    doc_install: conditional(bool),
    doc_install_dir: unix_filename, /* TODO: dest filename ?. */
    doc_title: string,
    doc_authors: list(string),
    doc_abstract: option(string),
    doc_format,
    /* TODO: src filename. */
    doc_data_files: list((unix_filename, option(unix_filename))),
    doc_build_tools: list(tool),
  };

  type section =
    | Library(common_section, build_section, library)
    | Object(common_section, build_section, object_)
    | Executable(common_section, build_section, executable)
    | Flag(common_section, flag)
    | SrcRepo(common_section, source_repository)
    | Test(common_section, test)
    | Doc(common_section, doc);

  type section_kind = [
    | `Library
    | `Object
    | `Executable
    | `Flag
    | `SrcRepo
    | `Test
    | `Doc
  ];

  type package = {
    oasis_version: OASISVersion.t,
    ocaml_version: option(OASISVersion.comparator),
    findlib_version: option(OASISVersion.comparator),
    alpha_features: list(string),
    beta_features: list(string),
    name: package_name,
    version: OASISVersion.t,
    license: OASISLicense.t,
    license_file: option(unix_filename), /* TODO: source filename. */
    copyrights: list(string),
    maintainers: list(string),
    authors: list(string),
    homepage: option(url),
    bugreports: option(url),
    synopsis: string,
    description: option(OASISText.t),
    tags: list(string),
    categories: list(url),
    conf_type: plugin([ | `Configure]),
    conf_custom: custom,
    build_type: plugin([ | `Build]),
    build_custom: custom,
    install_type: plugin([ | `Install]),
    install_custom: custom,
    uninstall_custom: custom,
    clean_custom: custom,
    distclean_custom: custom,
    files_ab: list(unix_filename), /* TODO: source filename. */
    sections: list(section),
    plugins: list(plugin([ | `Extra])),
    disable_oasis_section: list(unix_filename), /* TODO: source filename. */
    schema_data: PropList.Data.t,
    plugin_data,
  };
};

module OASISFeatures = {
  /* # 22 "src/oasis/OASISFeatures.ml" */

  open OASISTypes;
  open OASISUtils;
  open OASISGettext;
  open OASISVersion;

  module MapPlugin =
    Map.Make({
      type t = (plugin_kind, name);
      let compare = Pervasives.compare;
    });

  module Data = {
    type t = {
      oasis_version: OASISVersion.t,
      plugin_versions: MapPlugin.t(option(OASISVersion.t)),
      alpha_features: list(string),
      beta_features: list(string),
    };

    let create = (oasis_version, alpha_features, beta_features) => {
      oasis_version,
      plugin_versions: MapPlugin.empty,
      alpha_features,
      beta_features,
    };

    let of_package = pkg =>
      create(
        pkg.OASISTypes.oasis_version,
        pkg.OASISTypes.alpha_features,
        pkg.OASISTypes.beta_features,
      );

    let add_plugin = ((plugin_kind, plugin_name, plugin_version), t) => {
      ...t,
      plugin_versions:
        MapPlugin.add(
          (plugin_kind, plugin_name),
          plugin_version,
          t.plugin_versions,
        ),
    };

    let plugin_version = (plugin_kind, plugin_name, t) =>
      MapPlugin.find((plugin_kind, plugin_name), t.plugin_versions);

    let to_string = t =>
      Printf.sprintf(
        "oasis_version: %s; alpha_features: %s; beta_features: %s; plugins_version: %s",
        OASISVersion.string_of_version((t: t).oasis_version),
        String.concat(", ", t.alpha_features),
        String.concat(", ", t.beta_features),
        String.concat(
          ", ",
          MapPlugin.fold(
            ((_, plg), ver_opt, acc) => [
              plg
              ++ (
                switch (ver_opt) {
                | Some(v) => " " ++ OASISVersion.string_of_version(v)
                | None => ""
                }
              ),
              ...acc,
            ],
            t.plugin_versions,
            [],
          ),
        ),
      );
  };

  type origin =
    | Field(string, string)
    | Section(string)
    | NoOrigin;

  type stage =
    | Alpha
    | Beta;

  let string_of_stage =
    fun
    | Alpha => "alpha"
    | Beta => "beta";

  let field_of_stage =
    fun
    | Alpha => "AlphaFeatures"
    | Beta => "BetaFeatures";

  type publication =
    | InDev(stage)
    | SinceVersion(OASISVersion.t);

  type t = {
    name: string,
    plugin: option(all_plugin),
    publication,
    description: unit => string,
  };

  /* TODO: mutex protect this. */
  let all_features = Hashtbl.create(13);

  let since_version = ver_str => SinceVersion(version_of_string(ver_str));
  let alpha = InDev(Alpha);
  let beta = InDev(Beta);

  let to_string = t =>
    Printf.sprintf(
      "feature: %s; plugin: %s; publication: %s",
      (t: t).name,
      switch (t.plugin) {
      | None => "<none>"
      | Some((_, nm, _)) => nm
      },
      switch (t.publication) {
      | InDev(stage) => string_of_stage(stage)
      | SinceVersion(ver) => ">= " ++ OASISVersion.string_of_version(ver)
      },
    );

  let data_check = (t, data, origin) => {
    let no_message = "no message";

    let check_feature = (features, stage) => {
      let has_feature = List.mem((t: t).name, features);
      if (!has_feature) {
        switch ((origin: origin)) {
        | [@implicit_arity] Field(fld, where) =>
          Some(
            Printf.sprintf(
              f_(
                "Field %s in %s is only available when feature %s is in field %s.",
              ),
              fld,
              where,
              t.name,
              field_of_stage(stage),
            ),
          )
        | Section(sct) =>
          Some(
            Printf.sprintf(
              f_(
                "Section %s is only available when features %s is in field %s.",
              ),
              sct,
              t.name,
              field_of_stage(stage),
            ),
          )
        | NoOrigin => Some(no_message)
        };
      } else {
        None;
      };
    };

    let version_is_good = (~min_version, version, fmt) => {
      let version_is_good =
        OASISVersion.comparator_apply(
          version,
          OASISVersion.VGreaterEqual(min_version),
        );

      Printf.ksprintf(
        str =>
          if (version_is_good) {
            None;
          } else {
            Some(str);
          },
        fmt,
      );
    };

    switch (origin, t.plugin, t.publication) {
    | (_, _, InDev(Alpha)) => check_feature(data.Data.alpha_features, Alpha)
    | (_, _, InDev(Beta)) => check_feature(data.Data.beta_features, Beta)
    | ([@implicit_arity] Field(fld, where), None, SinceVersion(min_version)) =>
      version_is_good(
        ~min_version,
        data.Data.oasis_version,
        f_(
          "Field %s in %s is only valid since OASIS v%s, update OASISFormat field from '%s' to '%s' after checking OASIS changelog.",
        ),
        fld,
        where,
        string_of_version(min_version),
        string_of_version(data.Data.oasis_version),
        string_of_version(min_version),
      )

    | (
        [@implicit_arity] Field(fld, where),
        Some((plugin_knd, plugin_name, _)),
        SinceVersion(min_version),
      ) =>
      try (
        {
          let plugin_version_current =
            try (
              switch (Data.plugin_version(plugin_knd, plugin_name, data)) {
              | Some(ver) => ver
              | None =>
                failwithf(
                  f_(
                    "Field %s in %s is only valid for the OASIS plugin %s since v%s, but no plugin version is defined in the _oasis file, change '%s' to '%s (%s)' in your _oasis file.",
                  ),
                  fld,
                  where,
                  plugin_name,
                  string_of_version(min_version),
                  plugin_name,
                  plugin_name,
                  string_of_version(min_version),
                )
              }
            ) {
            | Not_found =>
              failwithf(
                f_(
                  "Field %s in %s is only valid when the OASIS plugin %s is defined.",
                ),
                fld,
                where,
                plugin_name,
              )
            };

          version_is_good(
            ~min_version,
            plugin_version_current,
            f_(
              "Field %s in %s is only valid for the OASIS plugin %s since v%s, update your plugin from '%s (%s)' to '%s (%s)' after checking the plugin's changelog.",
            ),
            fld,
            where,
            plugin_name,
            string_of_version(min_version),
            plugin_name,
            string_of_version(plugin_version_current),
            plugin_name,
            string_of_version(min_version),
          );
        }
      ) {
      | Failure(msg) => Some(msg)
      }

    | (Section(sct), None, SinceVersion(min_version)) =>
      version_is_good(
        ~min_version,
        data.Data.oasis_version,
        f_(
          "Section %s is only valid for since OASIS v%s, update OASISFormat field from '%s' to '%s' after checking OASIS changelog.",
        ),
        sct,
        string_of_version(min_version),
        string_of_version(data.Data.oasis_version),
        string_of_version(min_version),
      )

    | (
        Section(sct),
        Some((plugin_knd, plugin_name, _)),
        SinceVersion(min_version),
      ) =>
      try (
        {
          let plugin_version_current =
            try (
              switch (Data.plugin_version(plugin_knd, plugin_name, data)) {
              | Some(ver) => ver
              | None =>
                failwithf(
                  f_(
                    "Section %s is only valid for the OASIS plugin %s since v%s, but no plugin version is defined in the _oasis file, change '%s' to '%s (%s)' in your _oasis file.",
                  ),
                  sct,
                  plugin_name,
                  string_of_version(min_version),
                  plugin_name,
                  plugin_name,
                  string_of_version(min_version),
                )
              }
            ) {
            | Not_found =>
              failwithf(
                f_(
                  "Section %s is only valid when the OASIS plugin %s is defined.",
                ),
                sct,
                plugin_name,
              )
            };

          version_is_good(
            ~min_version,
            plugin_version_current,
            f_(
              "Section %s is only valid for the OASIS plugin %s since v%s, update your plugin from '%s (%s)' to '%s (%s)' after checking the plugin's changelog.",
            ),
            sct,
            plugin_name,
            string_of_version(min_version),
            plugin_name,
            string_of_version(plugin_version_current),
            plugin_name,
            string_of_version(min_version),
          );
        }
      ) {
      | Failure(msg) => Some(msg)
      }

    | (NoOrigin, None, SinceVersion(min_version)) =>
      version_is_good(~min_version, data.Data.oasis_version, "%s", no_message)

    | (
        NoOrigin,
        Some((plugin_knd, plugin_name, _)),
        SinceVersion(min_version),
      ) =>
      try (
        {
          let plugin_version_current =
            switch (Data.plugin_version(plugin_knd, plugin_name, data)) {
            | Some(ver) => ver
            | None => raise(Not_found)
            };

          version_is_good(
            ~min_version,
            plugin_version_current,
            "%s",
            no_message,
          );
        }
      ) {
      | Not_found => Some(no_message)
      }
    };
  };

  let data_assert = (t, data, origin) =>
    switch (data_check(t, data, origin)) {
    | None => ()
    | Some(str) => failwith(str)
    };

  let data_test = (t, data) =>
    switch (data_check(t, data, NoOrigin)) {
    | None => true
    | Some(_) => false
    };

  let package_test = (t, pkg) => data_test(t, Data.of_package(pkg));

  let create = (~plugin=?, name, publication, description) => {
    let () =
      if (Hashtbl.mem(all_features, name)) {
        failwithf("Feature '%s' is already declared.", name);
      };

    let t = {name, plugin, publication, description};

    Hashtbl.add(all_features, name, t);
    t;
  };

  let get_stage = name =>
    try (Hashtbl.find(all_features, name).publication) {
    | Not_found => failwithf(f_("Feature %s doesn't exist."), name)
    };

  let list = () =>
    Hashtbl.fold((_, v, acc) => [v, ...acc], all_features, []);

  /*
   * Real flags.
   */

  let features =
    create("features_fields", since_version("0.4"), () =>
      s_("Enable to experiment not yet official features.")
    );

  let flag_docs =
    create("flag_docs", since_version("0.3"), () =>
      s_("Make building docs require '-docs' flag at configure.")
    );

  let flag_tests =
    create("flag_tests", since_version("0.3"), () =>
      s_("Make running tests require '-tests' flag at configure.")
    );

  let pack =
    create("pack", since_version("0.3"), () =>
      s_("Allow to create packed library.")
    );

  let section_object =
    create("section_object", beta, () => s_("Implement an object section."));

  let dynrun_for_release =
    create("dynrun_for_release", alpha, () =>
      s_("Make '-setup-update dynamic' suitable for releasing project.")
    );

  let compiled_setup_ml =
    create("compiled_setup_ml", alpha, () =>
      s_("Compile the setup.ml and speed-up actions done with it.")
    );

  let disable_oasis_section =
    create("disable_oasis_section", alpha, () =>
      s_(
        "Allow the OASIS section comments and digests to be omitted in generated files.",
      )
    );

  let no_automatic_syntax =
    create("no_automatic_syntax", alpha, () =>
      s_(
        "Disable the automatic inclusion of -syntax camlp4o for packages that matches the internal heuristic (if a dependency ends with a .syntax or is a well known syntax).",
      )
    );

  let findlib_directory =
    create("findlib_directory", beta, () =>
      s_(
        "Allow to install findlib libraries in sub-directories of the target findlib directory.",
      )
    );

  let findlib_extra_files =
    create("findlib_extra_files", beta, () =>
      s_("Allow to install extra files for findlib libraries.")
    );

  let source_patterns =
    create("source_patterns", alpha, () =>
      s_("Customize mapping between module name and source file.")
    );
};

module OASISSection = {
  /* # 22 "src/oasis/OASISSection.ml" */

  open OASISTypes;

  let section_kind_common =
    fun
    | [@implicit_arity] Library(cs, _, _) => (`Library, cs)
    | [@implicit_arity] Object(cs, _, _) => (`Object, cs)
    | [@implicit_arity] Executable(cs, _, _) => (`Executable, cs)
    | [@implicit_arity] Flag(cs, _) => (`Flag, cs)
    | [@implicit_arity] SrcRepo(cs, _) => (`SrcRepo, cs)
    | [@implicit_arity] Test(cs, _) => (`Test, cs)
    | [@implicit_arity] Doc(cs, _) => (`Doc, cs);

  let section_common = sct => snd(section_kind_common(sct));

  let section_common_set = cs =>
    fun
    | [@implicit_arity] Library(_, bs, lib) =>
      [@implicit_arity] Library(cs, bs, lib)
    | [@implicit_arity] Object(_, bs, obj) =>
      [@implicit_arity] Object(cs, bs, obj)
    | [@implicit_arity] Executable(_, bs, exec) =>
      [@implicit_arity] Executable(cs, bs, exec)
    | [@implicit_arity] Flag(_, flg) => [@implicit_arity] Flag(cs, flg)
    | [@implicit_arity] SrcRepo(_, src_repo) =>
      [@implicit_arity] SrcRepo(cs, src_repo)
    | [@implicit_arity] Test(_, tst) => [@implicit_arity] Test(cs, tst)
    | [@implicit_arity] Doc(_, doc) => [@implicit_arity] Doc(cs, doc);

  /** Key used to identify section
  */

  let section_id = sct => {
    let (k, cs) = section_kind_common(sct);

    (k, cs.cs_name);
  };

  let string_of_section_kind =
    fun
    | `Library => "library"
    | `Object => "object"
    | `Executable => "executable"
    | `Flag => "flag"
    | `SrcRepo => "src repository"
    | `Test => "test"
    | `Doc => "doc";

  let string_of_section = sct => {
    let (k, nm) = section_id(sct);
    string_of_section_kind(k) ++ " " ++ nm;
  };

  let section_find = (id, scts) =>
    List.find(sct => id == section_id(sct), scts);

  module CSection = {
    type t = section;

    let id = section_id;

    let compare = (t1, t2) => compare(id(t1), id(t2));

    let equal = (t1, t2) => id(t1) == id(t2);

    let hash = t => Hashtbl.hash(id(t));
  };

  module MapSection = Map.Make(CSection);
  module SetSection = Set.Make(CSection);
};

module OASISBuildSection = {
  /* # 22 "src/oasis/OASISBuildSection.ml" */

  open OASISTypes;

  /* Look for a module file, considering capitalization or not. */
  let find_module = (source_file_exists, bs, modul) => {
    let possible_lst =
      OASISSourcePatterns.all_possible_files(
        bs.bs_interface_patterns @ bs.bs_implementation_patterns,
        ~path=bs.bs_path,
        ~modul,
      );

    switch (List.filter(source_file_exists, possible_lst)) {
    | [fn, ..._] as fn_lst =>
      `Sources((OASISUnixPath.chop_extension(fn), fn_lst))
    | [] =>
      open OASISUtils;
      let (_, rev_lst) =
        List.fold_left(
          ((set, acc), fn) => {
            let base_fn = OASISUnixPath.chop_extension(fn);
            if (SetString.mem(base_fn, set)) {
              (set, acc);
            } else {
              (SetString.add(base_fn, set), [base_fn, ...acc]);
            };
          },
          (SetString.empty, []),
          possible_lst,
        );

      `No_sources(List.rev(rev_lst));
    };
  };
};

module OASISExecutable = {
  /* # 22 "src/oasis/OASISExecutable.ml" */

  open OASISTypes;

  let unix_exec_is = ((cs, bs, exec), is_native, ext_dll, suffix_program) => {
    let dir =
      OASISUnixPath.concat(
        bs.bs_path,
        OASISUnixPath.dirname(exec.exec_main_is),
      );

    let is_native_exec =
      switch (bs.bs_compiled_object) {
      | Native => true
      | Best => is_native()
      | Byte => false
      };

    (
      OASISUnixPath.concat(dir, cs.cs_name ++ suffix_program()),
      if (!is_native_exec && !exec.exec_custom && bs.bs_c_sources != []) {
        Some(dir ++ "/dll" ++ cs.cs_name ++ "_stubs" ++ ext_dll());
      } else {
        None;
      },
    );
  };
};

module OASISLibrary = {
  /* # 22 "src/oasis/OASISLibrary.ml" */

  open OASISTypes;
  open OASISGettext;

  let find_module = (~ctxt, source_file_exists, cs, bs, modul) =>
    switch (OASISBuildSection.find_module(source_file_exists, bs, modul)) {
    | `Sources(_) as res => res
    | `No_sources(_) as res =>
      OASISMessage.warning(
        ~ctxt,
        f_("Cannot find source file matching module '%s' in library %s."),
        modul,
        cs.cs_name,
      );
      OASISMessage.warning(
        ~ctxt,
        f_(
          "Use InterfacePatterns or ImplementationPatterns to define this file with feature %S.",
        ),
        OASISFeatures.source_patterns.OASISFeatures.name,
      );
      res;
    };

  let source_unix_files = (~ctxt, (cs, bs, lib), source_file_exists) =>
    List.fold_left(
      (acc, modul) =>
        switch (find_module(~ctxt, source_file_exists, cs, bs, modul)) {
        | `Sources(base_fn, lst) => [(base_fn, lst), ...acc]
        | `No_sources(_) => acc
        },
      [],
      lib.lib_modules @ lib.lib_internal_modules,
    );

  let generated_unix_files =
      (
        ~ctxt,
        ~is_native,
        ~has_native_dynlink,
        ~ext_lib,
        ~ext_dll,
        ~source_file_exists,
        (cs, bs, lib),
      ) => {
    let find_modules = (lst, ext) => {
      let find_module = modul =>
        switch (find_module(~ctxt, source_file_exists, cs, bs, modul)) {
        | `Sources(_, [fn])
            when ext != "cmi" && Filename.check_suffix(fn, ".mli") =>
          None /* No implementation files for pure interface. */
        | `Sources(base_fn, _) => Some([base_fn])
        | `No_sources(lst) => Some(lst)
        };

      List.fold_left(
        (acc, nm) =>
          switch (find_module(nm)) {
          | None => acc
          | Some(base_fns) => [
              List.map(base_fn => base_fn ++ "." ++ ext, base_fns),
              ...acc,
            ]
          },
        [],
        lst,
      );
    };

    /* The .cmx that be compiled along */
    let cmxs = {
      let should_be_built =
        switch (bs.bs_compiled_object) {
        | Native => true
        | Best => is_native
        | Byte => false
        };

      if (should_be_built) {
        if (lib.lib_pack) {
          find_modules([cs.cs_name], "cmx");
        } else {
          find_modules(lib.lib_modules @ lib.lib_internal_modules, "cmx");
        };
      } else {
        [];
      };
    };

    let acc_nopath = [];

    /* The headers and annot/cmt files that should be compiled along */
    let headers = {
      let sufx =
        if (lib.lib_pack) {
          [".cmti", ".cmt", ".annot"];
        } else {
          [".cmi", ".cmti", ".cmt", ".annot"];
        };

      List.map(
        List.fold_left(
          (accu, s) => {
            let dot = String.rindex(s, '.');
            let base = String.sub(s, 0, dot);
            List.map((++)(base), sufx) @ accu;
          },
          [],
        ),
        find_modules(lib.lib_modules, "cmi"),
      );
    };

    /* Compute what libraries should be built */
    let acc_nopath = {
      /* Add the packed header file if required */
      let add_pack_header = acc =>
        if (lib.lib_pack) {
          [
            [
              cs.cs_name ++ ".cmi",
              cs.cs_name ++ ".cmti",
              cs.cs_name ++ ".cmt",
            ],
            ...acc,
          ];
        } else {
          acc;
        };

      let byte = acc => add_pack_header([[cs.cs_name ++ ".cma"], ...acc]);

      let native = acc => {
        let acc =
          add_pack_header(
            if (has_native_dynlink) {
              [[cs.cs_name ++ ".cmxs"], ...acc];
            } else {
              acc;
            },
          );

        [[cs.cs_name ++ ".cmxa"], [cs.cs_name ++ ext_lib], ...acc];
      };

      switch (bs.bs_compiled_object) {
      | Native => byte(native(acc_nopath))
      | Best when is_native => byte(native(acc_nopath))
      | Byte
      | Best => byte(acc_nopath)
      };
    };

    /* Add C library to be built */
    let acc_nopath =
      if (bs.bs_c_sources != []) {
        [
          ["lib" ++ cs.cs_name ++ "_stubs" ++ ext_lib],
          ...if (has_native_dynlink) {
               [["dll" ++ cs.cs_name ++ "_stubs" ++ ext_dll], ...acc_nopath];
             } else {
               acc_nopath;
             },
        ];
      } else {
        acc_nopath;
      };

    /* All the files generated */
    List.rev_append(
      List.rev_map(
        List.rev_map(OASISUnixPath.concat(bs.bs_path)),
        acc_nopath,
      ),
      headers @ cmxs,
    );
  };
};

module OASISObject = {
  /* # 22 "src/oasis/OASISObject.ml" */

  open OASISTypes;
  open OASISGettext;

  let find_module = (~ctxt, source_file_exists, cs, bs, modul) =>
    switch (OASISBuildSection.find_module(source_file_exists, bs, modul)) {
    | `Sources(_) as res => res
    | `No_sources(_) as res =>
      OASISMessage.warning(
        ~ctxt,
        f_("Cannot find source file matching module '%s' in object %s."),
        modul,
        cs.cs_name,
      );
      OASISMessage.warning(
        ~ctxt,
        f_(
          "Use InterfacePatterns or ImplementationPatterns to define this file with feature %S.",
        ),
        OASISFeatures.source_patterns.OASISFeatures.name,
      );
      res;
    };

  let source_unix_files = (~ctxt, (cs, bs, obj), source_file_exists) =>
    List.fold_left(
      (acc, modul) =>
        switch (find_module(~ctxt, source_file_exists, cs, bs, modul)) {
        | `Sources(base_fn, lst) => [(base_fn, lst), ...acc]
        | `No_sources(_) => acc
        },
      [],
      obj.obj_modules,
    );

  let generated_unix_files =
      (~ctxt, ~is_native, ~source_file_exists, (cs, bs, obj)) => {
    let find_module = (ext, modul) =>
      switch (find_module(~ctxt, source_file_exists, cs, bs, modul)) {
      | `Sources(base_fn, _) => [base_fn ++ ext]
      | `No_sources(lst) => lst
      };

    let (header, byte, native, c_object, f) =
      switch (obj.obj_modules) {
      | [m] => (
          find_module(".cmi", m),
          find_module(".cmo", m),
          find_module(".cmx", m),
          find_module(".o", m),
          (x => x),
        )
      | _ => (
          [cs.cs_name ++ ".cmi"],
          [cs.cs_name ++ ".cmo"],
          [cs.cs_name ++ ".cmx"],
          [cs.cs_name ++ ".o"],
          OASISUnixPath.concat(bs.bs_path),
        )
      };

    List.map(
      List.map(f),
      switch (bs.bs_compiled_object) {
      | Native => [native, c_object, byte, header]
      | Best when is_native => [native, c_object, byte, header]
      | Byte
      | Best => [byte, header]
      },
    );
  };
};

module OASISFindlib = {
  /* # 22 "src/oasis/OASISFindlib.ml" */

  open OASISTypes;
  open OASISUtils;
  open OASISGettext;

  type library_name = name;
  type findlib_part_name = name;
  type map_of_findlib_part_name('a) = OASISUtils.MapString.t('a);

  exception InternalLibraryNotFound(library_name);
  exception FindlibPackageNotFound(findlib_name);

  type group_t =
    | Container(findlib_name, list(group_t))
    | Package(
        (
          findlib_name,
          common_section,
          build_section,
          [ | `Library(library) | `Object(object_)],
          option(unix_dirname),
          list(group_t),
        ),
      );

  type data = (
    common_section,
    build_section,
    [ | `Library(library) | `Object(object_)],
  );
  type tree =
    | Node(option(data), MapString.t(tree))
    | Leaf(data);

  let findlib_mapping = pkg => {
    /* Map from library name to either full findlib name or parts + parent. */
    let fndlb_parts_of_lib_name = {
      let fndlb_parts = (cs, lib) => {
        let name =
          switch (lib.lib_findlib_name) {
          | Some(nm) => nm
          | None => cs.cs_name
          };

        let name = String.concat(".", lib.lib_findlib_containers @ [name]);

        name;
      };

      List.fold_left(
        mp =>
          fun
          | [@implicit_arity] Library(cs, _, lib) => {
              let lib_name = cs.cs_name;
              let fndlb_parts = fndlb_parts(cs, lib);
              if (MapString.mem(lib_name, mp)) {
                failwithf(
                  f_("The library name '%s' is used more than once."),
                  lib_name,
                );
              };
              switch (lib.lib_findlib_parent) {
              | Some(lib_name_parent) =>
                MapString.add(
                  lib_name,
                  `Unsolved((lib_name_parent, fndlb_parts)),
                  mp,
                )
              | None => MapString.add(lib_name, `Solved(fndlb_parts), mp)
              };
            }

          | [@implicit_arity] Object(cs, _, obj) => {
              let obj_name = cs.cs_name;
              if (MapString.mem(obj_name, mp)) {
                failwithf(
                  f_("The object name '%s' is used more than once."),
                  obj_name,
                );
              };
              let findlib_full_name =
                switch (obj.obj_findlib_fullname) {
                | Some(ns) => String.concat(".", ns)
                | None => obj_name
                };

              MapString.add(obj_name, `Solved(findlib_full_name), mp);
            }

          | Executable(_)
          | Test(_)
          | Flag(_)
          | SrcRepo(_)
          | Doc(_) => mp,
        MapString.empty,
        pkg.sections,
      );
    };

    /* Solve the above graph to be only library name to full findlib name. */
    let fndlb_name_of_lib_name = {
      let rec solve = (visited, mp, lib_name, lib_name_child) => {
        if (SetString.mem(lib_name, visited)) {
          failwithf(
            f_(
              "Library '%s' is involved in a cycle with regard to findlib naming.",
            ),
            lib_name,
          );
        };
        let visited = SetString.add(lib_name, visited);
        try (
          switch (MapString.find(lib_name, mp)) {
          | `Solved(fndlb_nm) => (fndlb_nm, mp)
          | `Unsolved(lib_nm_parent, post_fndlb_nm) =>
            let (pre_fndlb_nm, mp) =
              solve(visited, mp, lib_nm_parent, lib_name);

            let fndlb_nm = pre_fndlb_nm ++ "." ++ post_fndlb_nm;
            (fndlb_nm, MapString.add(lib_name, `Solved(fndlb_nm), mp));
          }
        ) {
        | Not_found =>
          failwithf(
            f_(
              "Library '%s', which is defined as the findlib parent of library '%s', doesn't exist.",
            ),
            lib_name,
            lib_name_child,
          )
        };
      };

      let mp =
        MapString.fold(
          (lib_name, status, mp) =>
            switch (status) {
            | `Solved(_) =>
              /* Solved initialy, no need to go further */
              mp
            | `Unsolved(_) =>
              let (_, mp) = solve(SetString.empty, mp, lib_name, "<none>");
              mp;
            },
          fndlb_parts_of_lib_name,
          fndlb_parts_of_lib_name,
        );

      MapString.map(
        fun
        | `Solved(fndlb_nm) => fndlb_nm
        | `Unsolved(_) => assert(false),
        mp,
      );
    };

    /* Convert an internal library name to a findlib name. */
    let findlib_name_of_library_name = lib_nm =>
      try (MapString.find(lib_nm, fndlb_name_of_lib_name)) {
      | Not_found => raise(InternalLibraryNotFound(lib_nm))
      };

    /* Add a library to the tree.
     */
    let add = (sct, mp) => {
      let fndlb_fullname = {
        let (cs, _, _) = sct;
        let lib_name = cs.cs_name;
        findlib_name_of_library_name(lib_name);
      };

      let rec add_children = (nm_lst, children: MapString.t(tree)) =>
        switch (nm_lst) {
        | [hd, ...tl] =>
          let node =
            try (add_node(tl, MapString.find(hd, children))) {
            | Not_found =>
              /* New node */
              new_node(tl)
            };

          MapString.add(hd, node, children);
        | [] =>
          /* Should not have a nameless library. */
          assert(false)
        }
      and add_node = (tl, node) =>
        if (tl == []) {
          switch (node) {
          | [@implicit_arity] Node(None, children) =>
            [@implicit_arity] Node(Some(sct), children)
          | [@implicit_arity] Leaf(cs', _, _)
          | [@implicit_arity] Node(Some((cs', _, _)), _) =>
            /* TODO: allow to merge Package, i.e.
              * archive(byte) = "foo.cma foo_init.cmo"
             */
            let (cs, _, _) = sct;
            failwithf(
              f_("Library '%s' and '%s' have the same findlib name '%s'"),
              cs.cs_name,
              cs'.cs_name,
              fndlb_fullname,
            );
          };
        } else {
          switch (node) {
          | Leaf(data) =>
            [@implicit_arity]
            Node(Some(data), add_children(tl, MapString.empty))
          | [@implicit_arity] Node(data_opt, children) =>
            [@implicit_arity] Node(data_opt, add_children(tl, children))
          };
        }
      and new_node =
        fun
        | [] => Leaf(sct)
        | [hd, ...tl] =>
          [@implicit_arity]
          Node(None, MapString.add(hd, new_node(tl), MapString.empty));

      add_children(OASISString.nsplit(fndlb_fullname, '.'), mp);
    };

    let unix_directory = (dn, lib) => {
      let directory =
        switch (lib) {
        | `Library(lib) => lib.lib_findlib_directory
        | `Object(obj) => obj.obj_findlib_directory
        };

      switch (dn, directory) {
      | (None, None) => None
      | (None, Some(dn))
      | (Some(dn), None) => Some(dn)
      | (Some(dn1), Some(dn2)) => Some(OASISUnixPath.concat(dn1, dn2))
      };
    };

    let rec group_of_tree = (dn, mp) =>
      MapString.fold(
        (nm, node, acc) => {
          let cur =
            switch (node) {
            | [@implicit_arity] Node(Some((cs, bs, lib)), children) =>
              let current_dn = unix_directory(dn, lib);
              [@implicit_arity]
              Package(
                nm,
                cs,
                bs,
                lib,
                current_dn,
                group_of_tree(current_dn, children),
              );
            | [@implicit_arity] Node(None, children) =>
              [@implicit_arity] Container(nm, group_of_tree(dn, children))
            | [@implicit_arity] Leaf(cs, bs, lib) =>
              let current_dn = unix_directory(dn, lib);
              [@implicit_arity] Package(nm, cs, bs, lib, current_dn, []);
            };

          [cur, ...acc];
        },
        mp,
        [],
      );

    let group_mp =
      List.fold_left(
        mp =>
          fun
          | [@implicit_arity] Library(cs, bs, lib) =>
            add((cs, bs, `Library(lib)), mp)
          | [@implicit_arity] Object(cs, bs, obj) =>
            add((cs, bs, `Object(obj)), mp)
          | _ => mp,
        MapString.empty,
        pkg.sections,
      );

    let groups = group_of_tree(None, group_mp);

    let library_name_of_findlib_name =
      lazy (
        /* Revert findlib_name_of_library_name. */
        MapString.fold(
          (k, v, mp) => MapString.add(v, k, mp),
          fndlb_name_of_lib_name,
          MapString.empty,
        )
      );

    let library_name_of_findlib_name = fndlb_nm =>
      try (
        MapString.find(fndlb_nm, Lazy.force(library_name_of_findlib_name))
      ) {
      | Not_found => raise(FindlibPackageNotFound(fndlb_nm))
      };

    (groups, findlib_name_of_library_name, library_name_of_findlib_name);
  };

  let findlib_of_group =
    fun
    | [@implicit_arity] Container(fndlb_nm, _)
    | [@implicit_arity] Package(fndlb_nm, _, _, _, _, _) => fndlb_nm;

  let root_of_group = grp => {
    let rec root_lib_aux =
      /* We do a DFS in the group. */
      fun
      | [@implicit_arity] Container(_, children) =>
        List.fold_left(
          (res, grp) =>
            if (res == None) {
              root_lib_aux(grp);
            } else {
              res;
            },
          None,
          children,
        )
      | [@implicit_arity] Package(_, cs, bs, lib, _, _) =>
        Some((cs, bs, lib));

    switch (root_lib_aux(grp)) {
    | Some(res) => res
    | None =>
      failwithf(
        f_("Unable to determine root library of findlib library '%s'"),
        findlib_of_group(grp),
      )
    };
  };
};

module OASISFlag = {
  /* # 22 "src/oasis/OASISFlag.ml" */
};

module OASISPackage = {
  /* # 22 "src/oasis/OASISPackage.ml" */
};

module OASISSourceRepository = {
  /* # 22 "src/oasis/OASISSourceRepository.ml" */
};

module OASISTest = {
  /* # 22 "src/oasis/OASISTest.ml" */
};

module OASISDocument = {
  /* # 22 "src/oasis/OASISDocument.ml" */
};

module OASISExec = {
  /* # 22 "src/oasis/OASISExec.ml" */

  open OASISGettext;
  open OASISUtils;
  open OASISMessage;

  /* TODO: I don't like this quote, it is there because $(rm) foo expands to
    * 'rm -f' foo...
   */
  let run = (~ctxt, ~f_exit_code=?, ~quote=true, cmd, args) => {
    let cmd =
      if (quote) {
        if (Sys.os_type == "Win32") {
          if (String.contains(cmd, ' ')) {
            /* Double the 1st double quote... win32... sigh */
            "\"" ++ Filename.quote(cmd);
          } else {
            cmd;
          };
        } else {
          Filename.quote(cmd);
        };
      } else {
        cmd;
      };

    let cmdline = String.concat(" ", [cmd, ...args]);

    info(~ctxt, f_("Running command '%s'"), cmdline);
    switch (f_exit_code, Sys.command(cmdline)) {
    | (None, 0) => ()
    | (None, i) =>
      failwithf(f_("Command '%s' terminated with error code %d"), cmdline, i)
    | (Some(f), i) => f(i)
    };
  };

  let run_read_output = (~ctxt, ~f_exit_code=?, cmd, args) => {
    let fn = Filename.temp_file("oasis-", ".txt");

    try (
      {
        let () =
          run(~ctxt, ~f_exit_code?, cmd, args @ [">", Filename.quote(fn)]);

        let chn = open_in(fn);

        let routput = ref([]);

        try (
          while (true) {
            routput := [input_line(chn), ...routput^];
          }
        ) {
        | End_of_file => ()
        };
        close_in(chn);
        Sys.remove(fn);
        List.rev(routput^);
      }
    ) {
    | e =>
      try (Sys.remove(fn)) {
      | _ => ()
      };
      raise(e);
    };
  };

  let run_read_one_line = (~ctxt, ~f_exit_code=?, cmd, args) =>
    switch (run_read_output(~ctxt, ~f_exit_code?, cmd, args)) {
    | [fst] => fst
    | lst =>
      failwithf(
        f_("Command return unexpected output %S"),
        String.concat("\n", lst),
      )
    };
};

module OASISFileUtil = {
  /* # 22 "src/oasis/OASISFileUtil.ml" */

  open OASISGettext;

  let file_exists_case = fn => {
    let dirname = Filename.dirname(fn);
    let basename = Filename.basename(fn);
    if (Sys.file_exists(dirname)) {
      if (basename == Filename.current_dir_name) {
        true;
      } else {
        List.mem(basename, Array.to_list(Sys.readdir(dirname)));
      };
    } else {
      false;
    };
  };

  let find_file = (~case_sensitive=true, paths, exts) => {
    /* Cardinal product of two list */
    let ( * ) = (lst1, lst2) =>
      List.flatten(List.map(a => List.map(b => (a, b), lst2), lst1));

    let rec combined_paths = lst =>
      switch (lst) {
      | [p1, p2, ...tl] =>
        let acc = List.map(((a, b)) => Filename.concat(a, b), p1 * p2);

        combined_paths([acc, ...tl]);
      | [e] => e
      | [] => []
      };

    let alternatives =
      List.map(
        ((p, e)) =>
          if (String.length(e) > 0 && e.[0] != '.') {
            p ++ "." ++ e;
          } else {
            p ++ e;
          },
        combined_paths(paths) * exts,
      );

    List.find(
      file =>
        (
          if (case_sensitive) {
            file_exists_case(file);
          } else {
            Sys.file_exists(file);
          }
        )
        && !Sys.is_directory(file),
      alternatives,
    );
  };

  let which = (~ctxt, prg) => {
    let path_sep =
      switch (Sys.os_type) {
      | "Win32" => ';'
      | _ => ':'
      };

    let path_lst = OASISString.nsplit(Sys.getenv("PATH"), path_sep);
    let exec_ext =
      switch (Sys.os_type) {
      | "Win32" => [
          "",
          ...OASISString.nsplit(Sys.getenv("PATHEXT"), path_sep),
        ]
      | _ => [""]
      };

    find_file(~case_sensitive=false, [path_lst, [prg]], exec_ext);
  };

  /**/**/

  let rec fix_dir = dn => {
    /* Windows hack because Sys.file_exists "src\\" = false when
      * Sys.file_exists "src" = true
     */
    let ln = String.length(dn);

    if (Sys.os_type == "Win32" && ln > 0 && dn.[ln - 1] == '\\') {
      fix_dir(String.sub(dn, 0, ln - 1));
    } else {
      dn;
    };
  };

  /**/**/

  let q = Filename.quote;

  let cp = (~ctxt, ~recurse=false, src, tgt) =>
    if (recurse) {
      switch (Sys.os_type) {
      | "Win32" => OASISExec.run(~ctxt, "xcopy", [q(src), q(tgt), "/E"])
      | _ => OASISExec.run(~ctxt, "cp", ["-r", q(src), q(tgt)])
      };
    } else {
      OASISExec.run(
        ~ctxt,
        switch (Sys.os_type) {
        | "Win32" => "copy"
        | _ => "cp"
        },
        [q(src), q(tgt)],
      );
    };

  let mkdir = (~ctxt, tgt) =>
    OASISExec.run(
      ~ctxt,
      switch (Sys.os_type) {
      | "Win32" => "md"
      | _ => "mkdir"
      },
      [q(tgt)],
    );

  let rec mkdir_parent = (~ctxt, f, tgt) => {
    let tgt = fix_dir(tgt);

    if (Sys.file_exists(tgt)) {
      if (!Sys.is_directory(tgt)) {
        OASISUtils.failwithf(
          f_(
            "Cannot create directory '%s', a file of the same name already exists",
          ),
          tgt,
        );
      };
    } else {
      mkdir_parent(~ctxt, f, Filename.dirname(tgt));
      if (!Sys.file_exists(tgt)) {
        f(tgt);
        mkdir(~ctxt, tgt);
      };
    };
  };

  let rmdir = (~ctxt, tgt) =>
    if (Sys.readdir(tgt) == [||]) {
      switch (Sys.os_type) {
      | "Win32" => OASISExec.run(~ctxt, "rd", [q(tgt)])
      | _ => OASISExec.run(~ctxt, "rm", ["-r", q(tgt)])
      };
    } else {
      OASISMessage.error(
        ~ctxt,
        f_("Cannot remove directory '%s': not empty."),
        tgt,
      );
    };

  let glob = (~ctxt, fn) => {
    let basename = Filename.basename(fn);

    if (String.length(basename) >= 2
        && basename.[0] == '*'
        && basename.[1] == '.') {
      let ext_len = String.length(basename) - 2;

      let ext = String.sub(basename, 2, ext_len);

      let dirname = Filename.dirname(fn);

      Array.fold_left(
        (acc, fn) =>
          try (
            {
              let fn_ext =
                String.sub(fn, String.length(fn) - ext_len, ext_len);

              if (fn_ext == ext) {
                [Filename.concat(dirname, fn), ...acc];
              } else {
                acc;
              };
            }
          ) {
          | Invalid_argument(_) => acc
          },
        [],
        Sys.readdir(dirname),
      );
    } else if (file_exists_case(fn)) {
      [fn];
    } else {
      [];
    };
  };
};

module BaseEnvLight = {
  /* # 22 "src/base/BaseEnvLight.ml" */

  module MapString = Map.Make(String);

  type t = MapString.t(string);

  let default_filename = Filename.concat(Sys.getcwd(), "setup.data");

  let load = (~allow_empty=false, ~filename=default_filename, ~stream=?, ()) => {
    let line = ref(1);
    let lexer = st => {
      let st_line =
        Stream.from(_ =>
          try (
            switch (Stream.next(st)) {
            | '\n' =>
              incr(line);
              Some('\n');
            | c => Some(c)
            }
          ) {
          | Stream.Failure => None
          }
        );

      Genlex.make_lexer(["="], st_line);
    };

    let rec read_file = (lxr, mp) =>
      switch (Stream.npeek(3, lxr)) {
      | [Genlex.Ident(nm), Genlex.Kwd("="), Genlex.String(value)] =>
        Stream.junk(lxr);
        Stream.junk(lxr);
        Stream.junk(lxr);
        read_file(lxr, MapString.add(nm, value, mp));
      | [] => mp
      | _ =>
        failwith(
          Printf.sprintf("Malformed data file '%s' line %d", filename, line^),
        )
      };

    switch (stream) {
    | Some(st) => read_file(lexer(st), MapString.empty)
    | None =>
      if (Sys.file_exists(filename)) {
        let chn = open_in_bin(filename);
        let st = Stream.of_channel(chn);
        try (
          {
            let mp = read_file(lexer(st), MapString.empty);
            close_in(chn);
            mp;
          }
        ) {
        | e =>
          close_in(chn);
          raise(e);
        };
      } else if (allow_empty) {
        MapString.empty;
      } else {
        failwith(
          Printf.sprintf(
            "Unable to load environment, the file '%s' doesn't exist.",
            filename,
          ),
        );
      }
    };
  };

  let rec var_expand = (str, env) => {
    let buff = Buffer.create(String.length(str) * 2);
    Buffer.add_substitute(
      buff,
      var =>
        try (var_expand(MapString.find(var, env), env)) {
        | Not_found =>
          failwith(
            Printf.sprintf(
              "No variable %s defined when trying to expand %S.",
              var,
              str,
            ),
          )
        },
      str,
    );
    Buffer.contents(buff);
  };

  let var_get = (name, env) => var_expand(MapString.find(name, env), env);
  let var_choose = (lst, env) =>
    OASISExpr.choose(nm => var_get(nm, env), lst);
};

module BaseContext = {
  /* # 22 "src/base/BaseContext.ml" */

  /* TODO: get rid of this module. */
  open OASISContext;

  let args = () => fst(fspecs());

  let default = default;
};

module BaseMessage = {
  /* # 22 "src/base/BaseMessage.ml" */

  /** Message to user, overrid for Base
      @author Sylvain Le Gall
  */
  open OASISMessage;
  open BaseContext;

  let debug = fmt => debug(~ctxt=default^, fmt);

  let info = fmt => info(~ctxt=default^, fmt);

  let warning = fmt => warning(~ctxt=default^, fmt);

  let error = fmt => error(~ctxt=default^, fmt);
};

module BaseEnv = {
  /* # 22 "src/base/BaseEnv.ml" */

  open OASISGettext;
  open OASISUtils;
  open OASISContext;
  open PropList;

  module MapString = BaseEnvLight.MapString;

  type origin_t =
    | ODefault
    | OGetEnv
    | OFileLoad
    | OCommandLine;

  type cli_handle_t =
    | CLINone
    | CLIAuto
    | CLIWith
    | CLIEnable
    | CLIUser(list((Arg.key, Arg.spec, Arg.doc)));

  type definition_t = {
    hide: bool,
    dump: bool,
    cli: cli_handle_t,
    arg_help: option(string),
    group: option(string),
  };

  let schema = Schema.create("environment");

  /* Environment data */
  let env = Data.create();

  /* Environment data from file */
  let env_from_file = ref(MapString.empty);

  /* Lexer for var */
  let var_lxr = Genlex.make_lexer([]);

  let rec var_expand = str => {
    let buff = Buffer.create(String.length(str) * 2);

    Buffer.add_substitute(
      buff,
      var =>
        /* TODO: this is a quick hack to allow calling Test.Command
          * without defining executable name really. I.e. if there is
          * an exec Executable toto, then $(toto) should be replace
          * by its real name. It is however useful to have this function
          * for other variable that depend on the host and should be
          * written better than that.
         */
        try (
          {
            let st = var_lxr(Stream.of_string(var));

            switch (Stream.npeek(3, st)) {
            | [Genlex.Ident("utoh"), Genlex.Ident(nm)] =>
              OASISHostPath.of_unix(var_get(nm))
            | [Genlex.Ident("utoh"), Genlex.String(s)] =>
              OASISHostPath.of_unix(s)
            | [Genlex.Ident("ocaml_escaped"), Genlex.Ident(nm)] =>
              String.escaped(var_get(nm))
            | [Genlex.Ident("ocaml_escaped"), Genlex.String(s)] =>
              String.escaped(s)
            | [Genlex.Ident(nm)] => var_get(nm)
            | _ =>
              failwithf(
                f_("Unknown expression '%s' in variable expansion of %s."),
                var,
                str,
              )
            };
          }
        ) {
        | [@implicit_arity] Unknown_field(_, _) =>
          failwithf(
            f_("No variable %s defined when trying to expand %S."),
            var,
            str,
          )
        | Stream.Error(e) =>
          failwithf(
            f_("Syntax error when parsing '%s' when trying to expand %S: %s"),
            var,
            str,
            e,
          )
        },
      str,
    );
    Buffer.contents(buff);
  }
  and var_get = name => {
    let vl =
      try (Schema.get(schema, env, name)) {
      | Unknown_field(_) as e =>
        try (MapString.find(name, env_from_file^)) {
        | Not_found => raise(e)
        }
      };

    var_expand(vl);
  };

  let var_choose = (~printer=?, ~name=?, lst) =>
    OASISExpr.choose(~printer?, ~name?, var_get, lst);

  let var_protect = vl => {
    let buff = Buffer.create(String.length(vl));

    String.iter(
      fun
      | '$' => Buffer.add_string(buff, "\\$")
      | c => Buffer.add_char(buff, c),
      vl,
    );
    Buffer.contents(buff);
  };

  let var_define =
      (
        ~hide=false,
        ~dump=true,
        ~short_desc=?,
        ~cli=CLINone,
        ~arg_help=?,
        ~group=?,
        name, /* TODO: type constraint on the fact that name must be a valid OCaml
                id */
        dflt,
      ) => {
    let default = [
      (OFileLoad, () => MapString.find(name, env_from_file^)),
      (ODefault, dflt),
      (OGetEnv, () => Sys.getenv(name)),
    ];

    let extra = {hide, dump, cli, arg_help, group};

    /* Try to find a value that can be defined
     */
    let var_get_low = lst => {
      let (errors, res) =
        List.fold_left(
          ((errors, res), (_, v)) =>
            if (res == None) {
              try (errors, Some(v())) {
              | Not_found => (errors, res)
              | Failure(rsn) => ([rsn, ...errors], res)
              | e => ([Printexc.to_string(e), ...errors], res)
              };
            } else {
              (errors, res);
            },
          ([], None),
          List.sort(
            ((o1, _), (o2, _)) => Pervasives.compare(o2, o1),
            lst,
          ),
        );

      switch (res, errors) {
      | (Some(v), _) => v
      | (None, []) => raise([@implicit_arity] Not_set(name, None))
      | (None, lst) =>
        raise(
          [@implicit_arity]
          Not_set(name, Some(String.concat(s_(", "), lst))),
        )
      };
    };

    let help =
      switch (short_desc) {
      | Some(fs) => Some(fs)
      | None => None
      };

    let var_get_lst =
      FieldRO.create(
        ~schema,
        ~name,
        ~parse=(~context=ODefault, s) => [(context, () => s)],
        ~print=var_get_low,
        ~default,
        ~update=(~context as _=?, x, old_x) => x @ old_x,
        ~help?,
        extra,
      );

    () => var_expand(var_get_low(var_get_lst(env)));
  };

  let var_redefine =
      (
        ~hide=?,
        ~dump=?,
        ~short_desc=?,
        ~cli=?,
        ~arg_help=?,
        ~group=?,
        name,
        dflt,
      ) =>
    if (Schema.mem(schema, name)) {
      /* TODO: look suspsicious, we want to memorize dflt not dflt () */
      Schema.set(schema, env, ~context=ODefault, name, dflt());
      () => var_get(name);
    } else {
      var_define(
        ~hide?,
        ~dump?,
        ~short_desc?,
        ~cli?,
        ~arg_help?,
        ~group?,
        name,
        dflt,
      );
    };

  let var_ignore = (_: unit => string) => ();

  let print_hidden =
    var_define(
      ~hide=true,
      ~dump=false,
      ~cli=CLIAuto,
      ~arg_help="Print even non-printable variable. (debug)",
      "print_hidden",
      () =>
      "false"
    );

  let var_all = () =>
    List.rev(
      Schema.fold(
        (acc, nm, def, _) =>
          if (!def.hide || bool_of_string(print_hidden())) {
            [nm, ...acc];
          } else {
            acc;
          },
        [],
        schema,
      ),
    );

  let default_filename = in_srcdir("setup.data");

  let load = (~ctxt, ~allow_empty=false, ~filename=default_filename, ()) =>
    OASISFileSystem.(
      env_from_file :=
        {
          let repr_filename = (ctxt.srcfs)#string_of_filename(filename);
          if ((ctxt.srcfs)#file_exists(filename)) {
            let buf = Buffer.create(13);
            defer_close(
              (ctxt.srcfs)#open_in(~mode=binary_in, filename),
              read_all(buf),
            );
            defer_close(
              (ctxt.srcfs)#open_in(~mode=binary_in, filename),
              rdr => {
                OASISMessage.info(
                  ~ctxt,
                  "Loading environment from %S.",
                  repr_filename,
                );
                BaseEnvLight.load(
                  ~allow_empty,
                  ~filename=repr_filename,
                  ~stream=stream_of_reader(rdr),
                  (),
                );
              },
            );
          } else if (allow_empty) {
            BaseEnvLight.MapString.empty;
          } else {
            failwith(
              Printf.sprintf(
                f_(
                  "Unable to load environment, the file '%s' doesn't exist.",
                ),
                repr_filename,
              ),
            );
          };
        }
    );

  let unload = () => {
    env_from_file := MapString.empty;
    Data.clear(env);
  };

  let dump = (~ctxt, ~filename=default_filename, ()) =>
    OASISFileSystem.(
      defer_close(
        (ctxt.OASISContext.srcfs)#open_out(~mode=binary_out, filename),
        wrtr => {
          let buf = Buffer.create(63);
          let output = (nm, value) =>
            Buffer.add_string(buf, Printf.sprintf("%s=%S\n", nm, value));

          let mp_todo =
            /* Dump data from schema */
            Schema.fold(
              (mp_todo, nm, def, _) => {
                if (def.dump) {
                  try (output(nm, Schema.get(schema, env, nm))) {
                  | Not_set(_) => ()
                  };
                };
                MapString.remove(nm, mp_todo);
              },
              env_from_file^,
              schema,
            );

          /* Dump data defined outside of schema */
          MapString.iter(output, mp_todo);
          wrtr#output(buf);
        },
      )
    );

  let print = () => {
    let printable_vars =
      Schema.fold(
        (acc, nm, def, short_descr_opt) =>
          if (!def.hide || bool_of_string(print_hidden())) {
            try (
              {
                let value = Schema.get(schema, env, nm);
                let txt =
                  switch (short_descr_opt) {
                  | Some(s) => s()
                  | None => nm
                  };

                [(txt, value), ...acc];
              }
            ) {
            | Not_set(_) => acc
            };
          } else {
            acc;
          },
        [],
        schema,
      );

    let max_length =
      List.fold_left(
        max,
        0,
        List.rev_map(String.length, List.rev_map(fst, printable_vars)),
      );

    let dot_pad = str =>
      String.make(max_length - String.length(str) + 3, '.');
    Printf.printf("\nConfiguration:\n");
    List.iter(
      ((name, value)) => {
        Printf.printf("%s: %s", name, dot_pad(name));
        if (value == "") {
          Printf.printf("\n");
        } else {
          Printf.printf(" %s\n", value);
        };
      },
      List.rev(printable_vars),
    );
    Printf.printf("\n%!");
  };

  let args = () => {
    let arg_concat = OASISUtils.varname_concat(~hyphen='-');
    [
      (
        "--override",
        Arg.Tuple(
          {
            let rvr = ref("");

            let rvl = ref("");

            [
              Arg.Set_string(rvr),
              Arg.Set_string(rvl),
              Arg.Unit(
                () =>
                  Schema.set(schema, env, ~context=OCommandLine, rvr^, rvl^),
              ),
            ];
          },
        ),
        "var+val  Override any configuration variable.",
      ),
    ]
    @ List.flatten(
        Schema.fold(
          (acc, name, def, short_descr_opt) => {
            let var_set = s =>
              Schema.set(schema, env, ~context=OCommandLine, name, s);

            let arg_name = OASISUtils.varname_of_string(~hyphen='-', name);

            let hlp =
              switch (short_descr_opt) {
              | Some(txt) => txt()
              | None => ""
              };

            let arg_hlp =
              switch (def.arg_help) {
              | Some(s) => s
              | None => "str"
              };

            let default_value =
              try (
                Printf.sprintf(f_(" [%s]"), Schema.get(schema, env, name))
              ) {
              | Not_set(_) => ""
              };

            let args =
              switch (def.cli) {
              | CLINone => []
              | CLIAuto => [
                  (
                    arg_concat("--", arg_name),
                    Arg.String(var_set),
                    Printf.sprintf(
                      f_("%s %s%s"),
                      arg_hlp,
                      hlp,
                      default_value,
                    ),
                  ),
                ]
              | CLIWith => [
                  (
                    arg_concat("--with-", arg_name),
                    Arg.String(var_set),
                    Printf.sprintf(
                      f_("%s %s%s"),
                      arg_hlp,
                      hlp,
                      default_value,
                    ),
                  ),
                ]
              | CLIEnable =>
                let dflt =
                  if (default_value == " [true]") {
                    s_(" [default: enabled]");
                  } else {
                    s_(" [default: disabled]");
                  };

                [
                  (
                    arg_concat("--enable-", arg_name),
                    Arg.Unit((() => var_set("true"))),
                    Printf.sprintf(f_(" %s%s"), hlp, dflt),
                  ),
                  (
                    arg_concat("--disable-", arg_name),
                    Arg.Unit((() => var_set("false"))),
                    Printf.sprintf(f_(" %s%s"), hlp, dflt),
                  ),
                ];
              | CLIUser(lst) => lst
              };

            [args, ...acc];
          },
          [],
          schema,
        ),
      );
  };
};

module BaseArgExt = {
  /* # 22 "src/base/BaseArgExt.ml" */

  open OASISUtils;
  open OASISGettext;

  let parse = (argv, args) => {
    /* Simulate command line for Arg */
    let current = ref(0);

    try (
      Arg.parse_argv(
        ~current,
        Array.concat([[|"none"|], argv]),
        Arg.align(args),
        failwithf(f_("Don't know what to do with arguments: '%s'")),
        s_("configure options:"),
      )
    ) {
    | Arg.Help(txt) =>
      print_endline(txt);
      exit(0);
    | Arg.Bad(txt) =>
      prerr_endline(txt);
      exit(1);
    };
  };
};

module BaseCheck = {
  /* # 22 "src/base/BaseCheck.ml" */

  open BaseEnv;
  open BaseMessage;
  open OASISUtils;
  open OASISGettext;

  let prog_best = (prg, prg_lst) =>
    var_redefine(
      prg,
      () => {
        let alternate =
          List.fold_left(
            (res, e) =>
              switch (res) {
              | Some(_) => res
              | None =>
                try (
                  Some(OASISFileUtil.which(~ctxt=BaseContext.default^, e))
                ) {
                | Not_found => None
                }
              },
            None,
            prg_lst,
          );

        switch (alternate) {
        | Some(prg) => prg
        | None => raise(Not_found)
        };
      },
    );

  let prog = prg => prog_best(prg, [prg]);

  let prog_opt = prg => prog_best(prg, [prg ++ ".opt", prg]);

  let ocamlfind = prog("ocamlfind");

  let version = (var_prefix, cmp, fversion, ()) => {
    /* Really compare version provided */
    let var =
      var_prefix ++ "_version_" ++ OASISVersion.varname_of_comparator(cmp);

    var_redefine(
      ~hide=true,
      var,
      () => {
        let version_str =
          switch (fversion()) {
          | "[Distributed with OCaml]" =>
            try (var_get("ocaml_version")) {
            | Not_found =>
              warning(
                f_("Variable ocaml_version not defined, fallback to default"),
              );
              Sys.ocaml_version;
            }
          | res => res
          };

        let version = OASISVersion.version_of_string(version_str);

        if (OASISVersion.comparator_apply(version, cmp)) {
          version_str;
        } else {
          failwithf(
            f_("Cannot satisfy version constraint on %s: %s (version: %s)"),
            var_prefix,
            OASISVersion.string_of_comparator(cmp),
            version_str,
          );
        };
      },
      (),
    );
  };

  let package_version = pkg =>
    OASISExec.run_read_one_line(
      ~ctxt=BaseContext.default^,
      ocamlfind(),
      ["query", "-format", "%v", pkg],
    );

  let package = (~version_comparator=?, pkg, ()) => {
    let var =
      OASISUtils.varname_concat("pkg_", OASISUtils.varname_of_string(pkg));

    let findlib_dir = pkg => {
      let dir =
        OASISExec.run_read_one_line(
          ~ctxt=BaseContext.default^,
          ocamlfind(),
          ["query", "-format", "%d", pkg],
        );

      if (Sys.file_exists(dir) && Sys.is_directory(dir)) {
        dir;
      } else {
        failwithf(
          f_(
            "When looking for findlib package %s, directory %s return doesn't exist",
          ),
          pkg,
          dir,
        );
      };
    };

    let vl = var_redefine(var, () => findlib_dir(pkg), ());

    switch (version_comparator) {
    | Some(ver_cmp) =>
      ignore(version(var, ver_cmp, _ => package_version(pkg), ()))
    | None => ()
    };
    vl;
  };
};

module BaseOCamlcConfig = {
  /* # 22 "src/base/BaseOCamlcConfig.ml" */

  open BaseEnv;
  open OASISUtils;
  open OASISGettext;

  module SMap = Map.Make(String);

  let ocamlc = BaseCheck.prog_opt("ocamlc");

  let ocamlc_config_map = {
    /* Map name to value for ocamlc -config output
          (name ^": "^value)
       */
    let rec split_field = (mp, lst) =>
      switch (lst) {
      | [line, ...tl] =>
        let mp =
          try (
            {
              let pos_semicolon = String.index(line, ':');

              if (pos_semicolon > 1) {
                let name = String.sub(line, 0, pos_semicolon);

                let linelen = String.length(line);

                let value =
                  if (linelen > pos_semicolon + 2) {
                    String.sub(
                      line,
                      pos_semicolon + 2,
                      linelen - pos_semicolon - 2,
                    );
                  } else {
                    "";
                  };

                SMap.add(name, value, mp);
              } else {
                mp;
              };
            }
          ) {
          | Not_found => mp
          };

        split_field(mp, tl);
      | [] => mp
      };

    let cache =
      lazy (
        var_protect(
          Marshal.to_string(
            split_field(
              SMap.empty,
              OASISExec.run_read_output(
                ~ctxt=BaseContext.default^,
                ocamlc(),
                ["-config"],
              ),
            ),
            [],
          ),
        )
      );

    var_redefine("ocamlc_config_map", ~hide=true, ~dump=false, ()
      /* TODO: update if ocamlc change !!! */
      => Lazy.force(cache));
  };

  let var_define = nm => {
    /* Extract data from ocamlc -config */
    let avlbl_config_get = () => Marshal.from_string(ocamlc_config_map(), 0);

    let chop_version_suffix = s =>
      try (String.sub(s, 0, String.index(s, '+'))) {
      | _ => s
      };

    let (nm_config, value_config) =
      switch (nm) {
      | "ocaml_version" => ("version", chop_version_suffix)
      | _ => (nm, (x => x))
      };

    var_redefine(nm, () =>
      try (
        {
          let map = avlbl_config_get();

          let value = SMap.find(nm_config, map);

          value_config(value);
        }
      ) {
      | Not_found =>
        failwithf(
          f_("Cannot find field '%s' in '%s -config' output"),
          nm,
          ocamlc(),
        )
      }
    );
  };
};

module BaseStandardVar = {
  /* # 22 "src/base/BaseStandardVar.ml" */

  open OASISGettext;
  open OASISTypes;
  open BaseCheck;
  open BaseEnv;

  let ocamlfind = BaseCheck.ocamlfind;
  let ocamlc = BaseOCamlcConfig.ocamlc;
  let ocamlopt = prog_opt("ocamlopt");
  let ocamlbuild = prog("ocamlbuild");

  /**/**/

  let rpkg = ref(None);

  let pkg_get = () =>
    switch (rpkg^) {
    | Some(pkg) => pkg
    | None => failwith(s_("OASIS Package is not set"))
    };

  let var_cond = ref([]);

  let var_define_cond = (~since_version, f, dflt) => {
    let holder = ref(() => dflt);
    let since_version =
      OASISVersion.VGreaterEqual(
        OASISVersion.version_of_string(since_version),
      );

    var_cond :=
      [
        ver =>
          if (OASISVersion.comparator_apply(ver, since_version)) {
            holder := f();
          },
        ...var_cond^,
      ];
    () => holder^();
  };

  /**/**/;

  /**/**/

  let pkg_name =
    var_define(
      ~short_desc=() => s_("Package name"),
      "pkg_name",
      () => pkg_get().name,
    );

  let pkg_version =
    var_define(
      ~short_desc=() => s_("Package version"),
      "pkg_version",
      () => OASISVersion.string_of_version(pkg_get().version),
    );

  let c = BaseOCamlcConfig.var_define;

  let os_type = c("os_type");
  let system = c("system");
  let architecture = c("architecture");
  let ccomp_type = c("ccomp_type");
  let ocaml_version = c("ocaml_version");

  /* TODO: Check standard variable presence at runtime */

  let standard_library_default = c("standard_library_default");
  let standard_library = c("standard_library");
  let standard_runtime = c("standard_runtime");
  let bytecomp_c_compiler = c("bytecomp_c_compiler");
  let native_c_compiler = c("native_c_compiler");
  let model = c("model");
  let ext_obj = c("ext_obj");
  let ext_asm = c("ext_asm");
  let ext_lib = c("ext_lib");
  let ext_dll = c("ext_dll");
  let default_executable_name = c("default_executable_name");
  let systhread_supported = c("systhread_supported");

  let flexlink = BaseCheck.prog("flexlink");

  let flexdll_version =
    var_define(
      ~short_desc=() => "FlexDLL version (Win32)",
      "flexdll_version",
      () => {
        let lst =
          OASISExec.run_read_output(
            ~ctxt=BaseContext.default^,
            flexlink(),
            ["-help"],
          );

        switch (lst) {
        | [line, ..._] => Scanf.sscanf(line, "FlexDLL version %s", ver => ver)
        | [] => raise(Not_found)
        };
      },
    );

  /**/**/

  let p = (name, hlp, dflt) =>
    var_define(~short_desc=hlp, ~cli=CLIAuto, ~arg_help="dir", name, dflt);

  /**/**/

  let (/) = (a, b) =>
    if (os_type() == Sys.os_type) {
      Filename.concat(a, b);
    } else if (os_type() == "Unix" || os_type() == "Cygwin") {
      OASISUnixPath.concat(a, b);
    } else {
      OASISUtils.failwithf(
        f_("Cannot handle os_type %s filename concat"),
        os_type(),
      );
    };

  let prefix =
    p(
      "prefix",
      () => s_("Install architecture-independent files dir"),
      () =>
        switch (os_type()) {
        | "Win32" =>
          let program_files = Sys.getenv("PROGRAMFILES");

          program_files / pkg_name();
        | _ => "/usr/local"
        },
    );

  let exec_prefix =
    p(
      "exec_prefix",
      () => s_("Install architecture-dependent files in dir"),
      () => "$prefix",
    );

  let bindir =
    p("bindir", () => s_("User executables"), () => "$exec_prefix" / "bin");

  let sbindir =
    p(
      "sbindir",
      () => s_("System admin executables"),
      () => "$exec_prefix" / "sbin",
    );

  let libexecdir =
    p(
      "libexecdir",
      () => s_("Program executables"),
      () => "$exec_prefix" / "libexec",
    );

  let sysconfdir =
    p(
      "sysconfdir",
      () => s_("Read-only single-machine data"),
      () => "$prefix" / "etc",
    );

  let sharedstatedir =
    p(
      "sharedstatedir",
      () => s_("Modifiable architecture-independent data"),
      () => "$prefix" / "com",
    );

  let localstatedir =
    p(
      "localstatedir",
      () => s_("Modifiable single-machine data"),
      () => "$prefix" / "var",
    );

  let libdir =
    p(
      "libdir",
      () => s_("Object code libraries"),
      () => "$exec_prefix" / "lib",
    );

  let datarootdir =
    p(
      "datarootdir",
      () => s_("Read-only arch-independent data root"),
      () => "$prefix" / "share",
    );

  let datadir =
    p(
      "datadir",
      () => s_("Read-only architecture-independent data"),
      () => "$datarootdir",
    );

  let infodir =
    p(
      "infodir",
      () => s_("Info documentation"),
      () => "$datarootdir" / "info",
    );

  let localedir =
    p(
      "localedir",
      () => s_("Locale-dependent data"),
      () => "$datarootdir" / "locale",
    );

  let mandir =
    p("mandir", () => s_("Man documentation"), () => "$datarootdir" / "man");

  let docdir =
    p(
      "docdir",
      () => s_("Documentation root"),
      () => "$datarootdir" / "doc" / "$pkg_name",
    );

  let htmldir =
    p("htmldir", () => s_("HTML documentation"), () => "$docdir");

  let dvidir = p("dvidir", () => s_("DVI documentation"), () => "$docdir");

  let pdfdir = p("pdfdir", () => s_("PDF documentation"), () => "$docdir");

  let psdir = p("psdir", () => s_("PS documentation"), () => "$docdir");

  let destdir =
    p(
      "destdir",
      () => s_("Prepend a path when installing package"),
      () =>
        raise(
          [@implicit_arity]
          PropList.Not_set("destdir", Some(s_("undefined by construct"))),
        ),
    );

  let findlib_version =
    var_define("findlib_version", () => BaseCheck.package_version("findlib"));

  let is_native =
    var_define("is_native", () =>
      try (
        {
          let _s: string = ocamlopt();

          "true";
        }
      ) {
      | PropList.Not_set(_) =>
        let _s: string = ocamlc();

        "false";
      }
    );

  let ext_program =
    var_define("suffix_program", () =>
      switch (os_type()) {
      | "Win32"
      | "Cygwin" => ".exe"
      | _ => ""
      }
    );

  let rm =
    var_define(
      ~short_desc=() => s_("Remove a file."),
      "rm",
      () =>
        switch (os_type()) {
        | "Win32" => "del"
        | _ => "rm -f"
        },
    );

  let rmdir =
    var_define(
      ~short_desc=() => s_("Remove a directory."),
      "rmdir",
      () =>
        switch (os_type()) {
        | "Win32" => "rd"
        | _ => "rm -rf"
        },
    );

  let debug =
    var_define(
      ~short_desc=() => s_("Turn ocaml debug flag on"),
      ~cli=CLIEnable,
      "debug",
      () => "true",
    );

  let profile =
    var_define(
      ~short_desc=() => s_("Turn ocaml profile flag on"),
      ~cli=CLIEnable,
      "profile",
      () => "false",
    );

  let tests =
    var_define_cond(
      ~since_version="0.3",
      () =>
        var_define(
          ~short_desc=
            () => s_("Compile tests executable and library and run them"),
          ~cli=CLIEnable,
          "tests",
          () => "false",
        ),
      "true",
    );

  let docs =
    var_define_cond(
      ~since_version="0.3",
      () =>
        var_define(
          ~short_desc=() => s_("Create documentations"),
          ~cli=CLIEnable,
          "docs",
          () => "true",
        ),
      "true",
    );

  let native_dynlink =
    var_define(
      ~short_desc=() => s_("Compiler support generation of .cmxs."),
      ~cli=CLINone,
      "native_dynlink",
      () => {
        let res = {
          let ocaml_lt_312 = () =>
            OASISVersion.comparator_apply(
              OASISVersion.version_of_string(ocaml_version()),
              OASISVersion.VLesser(OASISVersion.version_of_string("3.12.0")),
            );

          let flexdll_lt_030 = () =>
            OASISVersion.comparator_apply(
              OASISVersion.version_of_string(flexdll_version()),
              OASISVersion.VLesser(OASISVersion.version_of_string("0.30")),
            );

          let has_native_dynlink = {
            let ocamlfind = ocamlfind();
            try (
              {
                let fn =
                  OASISExec.run_read_one_line(
                    ~ctxt=BaseContext.default^,
                    ocamlfind,
                    [
                      "query",
                      "-predicates",
                      "native",
                      "dynlink",
                      "-format",
                      "%d/%a",
                    ],
                  );

                Sys.file_exists(fn);
              }
            ) {
            | _ => false
            };
          };

          if (!has_native_dynlink) {
            false;
          } else if (ocaml_lt_312()) {
            false;
          } else if ((os_type() == "Win32" || os_type() == "Cygwin")
                     && flexdll_lt_030()) {
            BaseMessage.warning(
              f_(
                ".cmxs generation disabled because FlexDLL needs to be at least 0.30. Please upgrade FlexDLL from %s to 0.30.",
              ),
              flexdll_version(),
            );
            false;
          } else {
            true;
          };
        };

        string_of_bool(res);
      },
    );

  let init = pkg => {
    rpkg := Some(pkg);
    List.iter(f => f(pkg.oasis_version), var_cond^);
  };
};

module BaseFileAB = {
  /* # 22 "src/base/BaseFileAB.ml" */

  open BaseEnv;
  open OASISGettext;
  open BaseMessage;
  open OASISContext;

  let to_filename = fn => {
    if (!Filename.check_suffix(fn, ".ab")) {
      warning(f_("File '%s' doesn't have '.ab' extension"), fn);
    };
    OASISFileSystem.of_unix_filename(Filename.chop_extension(fn));
  };

  let replace = (~ctxt, fn_lst) => {
    open OASISFileSystem;
    let (ibuf, obuf) = (Buffer.create(13), Buffer.create(13));
    List.iter(
      fn => {
        Buffer.clear(ibuf);
        Buffer.clear(obuf);
        defer_close(
          (ctxt.srcfs)#open_in(of_unix_filename(fn)),
          read_all(ibuf),
        );
        Buffer.add_string(obuf, var_expand(Buffer.contents(ibuf)));
        defer_close((ctxt.srcfs)#open_out(to_filename(fn)), wrtr =>
          wrtr#output(obuf)
        );
      },
      fn_lst,
    );
  };
};

module BaseLog = {
  /* # 22 "src/base/BaseLog.ml" */

  open OASISUtils;
  open OASISContext;
  open OASISGettext;
  open OASISFileSystem;

  let default_filename = in_srcdir("setup.log");

  let load = (~ctxt, ()) => {
    module SetTupleString =
      Set.Make({
        type t = (string, string);
        let compare = ((s11, s12), (s21, s22)) =>
          switch (String.compare(s11, s21)) {
          | 0 => String.compare(s12, s22)
          | n => n
          };
      });

    if ((ctxt.srcfs)#file_exists(default_filename)) {
      defer_close(
        (ctxt.srcfs)#open_in(default_filename),
        rdr => {
          let line = ref(1);
          let lxr = Genlex.make_lexer([], stream_of_reader(rdr));
          let rec read_aux = ((st, lst)) =>
            switch (Stream.npeek(2, lxr)) {
            | [Genlex.String(e), Genlex.String(d)] =>
              let t = (e, d);
              Stream.junk(lxr);
              Stream.junk(lxr);
              if (SetTupleString.mem(t, st)) {
                read_aux((st, lst));
              } else {
                read_aux((SetTupleString.add(t, st), [t, ...lst]));
              };
            | [] => List.rev(lst)
            | _ =>
              failwithf(
                f_("Malformed log file '%s' at line %d"),
                (ctxt.srcfs)#string_of_filename(default_filename),
                line^,
              )
            };

          read_aux((SetTupleString.empty, []));
        },
      );
    } else {
      [];
    };
  };

  let register = (~ctxt, event, data) =>
    defer_close(
      (ctxt.srcfs)#open_out(
        ~mode=[Open_append, Open_creat, Open_text],
        ~perm=420,
        default_filename,
      ),
      wrtr => {
        let buf = Buffer.create(13);
        Printf.bprintf(buf, "%S %S\n", event, data);
        wrtr#output(buf);
      },
    );

  let unregister = (~ctxt, event, data) => {
    let lst = load(~ctxt, ());
    let buf = Buffer.create(13);
    List.iter(
      ((e, d)) =>
        if (e != event || d != data) {
          Printf.bprintf(buf, "%S %S\n", e, d);
        },
      lst,
    );
    if (Buffer.length(buf) > 0) {
      defer_close((ctxt.srcfs)#open_out(default_filename), wrtr =>
        wrtr#output(buf)
      );
    } else {
      (ctxt.srcfs)#remove(default_filename);
    };
  };

  let filter = (~ctxt, events) => {
    let st_events = SetString.of_list(events);
    List.filter(((e, _)) => SetString.mem(e, st_events), load(~ctxt, ()));
  };

  let exists = (~ctxt, event, data) =>
    List.exists(v => (event, data) == v, load(~ctxt, ()));
};

module BaseBuilt = {
  /* # 22 "src/base/BaseBuilt.ml" */

  open OASISTypes;
  open OASISGettext;
  open BaseStandardVar;
  open BaseMessage;

  type t =
    | BExec /* Executable */
    | BExecLib /* Library coming with executable */
    | BLib /* Library */
    | BObj /* Library */
    | BDoc; /* Document */

  let to_log_event_file = (t, nm) =>
    "built_"
    ++ (
      switch (t) {
      | BExec => "exec"
      | BExecLib => "exec_lib"
      | BLib => "lib"
      | BObj => "obj"
      | BDoc => "doc"
      }
    )
    ++ "_"
    ++ nm;

  let to_log_event_done = (t, nm) => "is_" ++ to_log_event_file(t, nm);

  let register = (~ctxt, t, nm, lst) => {
    BaseLog.register(~ctxt, to_log_event_done(t, nm), "true");
    List.iter(
      alt => {
        let registered =
          List.fold_left(
            (registered, fn) =>
              if (OASISFileUtil.file_exists_case(fn)) {
                BaseLog.register(
                  ~ctxt,
                  to_log_event_file(t, nm),
                  if (Filename.is_relative(fn)) {
                    Filename.concat(Sys.getcwd(), fn);
                  } else {
                    fn;
                  },
                );
                true;
              } else {
                registered;
              },
            false,
            alt,
          );

        if (!registered) {
          warning(
            f_("Cannot find an existing alternative files among: %s"),
            String.concat(s_(", "), alt),
          );
        };
      },
      lst,
    );
  };

  let unregister = (~ctxt, t, nm) =>
    List.iter(
      ((e, d)) => BaseLog.unregister(~ctxt, e, d),
      BaseLog.filter(
        ~ctxt,
        [to_log_event_file(t, nm), to_log_event_done(t, nm)],
      ),
    );

  let fold = (~ctxt, t, nm, f, acc) =>
    List.fold_left(
      (acc, (_, fn)) =>
        if (OASISFileUtil.file_exists_case(fn)) {
          f(acc, fn);
        } else {
          warning(
            f_("File '%s' has been marked as built for %s but doesn't exist"),
            fn,
            Printf.sprintf(
              switch (t) {
              | BExec
              | BExecLib => f_("executable %s")
              | BLib => f_("library %s")
              | BObj => f_("object %s")
              | BDoc => f_("documentation %s")
              },
              nm,
            ),
          );
          acc;
        },
      acc,
      BaseLog.filter(~ctxt, [to_log_event_file(t, nm)]),
    );

  let is_built = (~ctxt, t, nm) =>
    List.fold_left(
      (_, (_, d)) =>
        try (bool_of_string(d)) {
        | _ => false
        },
      false,
      BaseLog.filter(~ctxt, [to_log_event_done(t, nm)]),
    );

  let of_executable = (ffn, (cs, bs, exec)) => {
    let (unix_exec_is, unix_dll_opt) =
      OASISExecutable.unix_exec_is(
        (cs, bs, exec),
        () => bool_of_string(is_native()),
        ext_dll,
        ext_program,
      );

    let evs = [
      (BExec, cs.cs_name, [[ffn(unix_exec_is)]]),
      ...switch (unix_dll_opt) {
         | Some(fn) => [(BExecLib, cs.cs_name, [[ffn(fn)]])]
         | None => []
         },
    ];

    (evs, unix_exec_is, unix_dll_opt);
  };

  let of_library = (ffn, (cs, bs, lib)) => {
    let unix_lst =
      OASISLibrary.generated_unix_files(
        ~ctxt=BaseContext.default^,
        ~source_file_exists=
          fn => OASISFileUtil.file_exists_case(OASISHostPath.of_unix(fn)),
        ~is_native=bool_of_string(is_native()),
        ~has_native_dynlink=bool_of_string(native_dynlink()),
        ~ext_lib=ext_lib(),
        ~ext_dll=ext_dll(),
        (cs, bs, lib),
      );

    let evs = [(BLib, cs.cs_name, List.map(List.map(ffn), unix_lst))];

    (evs, unix_lst);
  };

  let of_object = (ffn, (cs, bs, obj)) => {
    let unix_lst =
      OASISObject.generated_unix_files(
        ~ctxt=BaseContext.default^,
        ~source_file_exists=
          fn => OASISFileUtil.file_exists_case(OASISHostPath.of_unix(fn)),
        ~is_native=bool_of_string(is_native()),
        (cs, bs, obj),
      );

    let evs = [(BObj, cs.cs_name, List.map(List.map(ffn), unix_lst))];

    (evs, unix_lst);
  };
};

module BaseCustom = {
  /* # 22 "src/base/BaseCustom.ml" */

  open BaseEnv;
  open BaseMessage;
  open OASISTypes;
  open OASISGettext;

  let run = (cmd, args, extra_args) =>
    OASISExec.run(
      ~ctxt=BaseContext.default^,
      ~quote=false,
      var_expand(cmd),
      List.map(var_expand, args @ Array.to_list(extra_args)),
    );

  let hook = (~failsafe=false, cstm, f, e) => {
    let optional_command = lst => {
      let printer =
        fun
        | Some((cmd, args)) => String.concat(" ", [cmd, ...args])
        | None => s_("No command");

      switch (var_choose(~name=s_("Pre/Post Command"), ~printer, lst)) {
      | Some((cmd, args)) =>
        try (run(cmd, args, [||])) {
        | e when failsafe =>
          warning(
            f_("Command '%s' fail with error: %s"),
            String.concat(" ", [cmd, ...args]),
            switch (e) {
            | Failure(msg) => msg
            | e => Printexc.to_string(e)
            },
          )
        }
      | None => ()
      };
    };

    let res = {
      optional_command(cstm.pre_command);
      f(e);
    };

    optional_command(cstm.post_command);
    res;
  };
};

module BaseDynVar = {
  /* # 22 "src/base/BaseDynVar.ml" */

  open OASISTypes;
  open OASISGettext;
  open BaseEnv;
  open BaseBuilt;

  let init = (~ctxt, pkg) =>
    /* TODO: disambiguate exec vs other variable by adding exec_VARNAME. */
    /* TODO: provide compile option for library libary_byte_args_VARNAME... */
    List.iter(
      fun
      | [@implicit_arity] Executable(cs, bs, _) =>
        if (var_choose(bs.bs_build)) {
          var_ignore(
            var_redefine(
              /* We don't save this variable */
              ~dump=false,
              ~short_desc=
                () =>
                  Printf.sprintf(
                    f_("Filename of executable '%s'"),
                    cs.cs_name,
                  ),
              OASISUtils.varname_of_string(cs.cs_name),
              () => {
                let fn_opt =
                  fold(~ctxt, BExec, cs.cs_name, (_, fn) => Some(fn), None);

                switch (fn_opt) {
                | Some(fn) => fn
                | None =>
                  raise(
                    [@implicit_arity]
                    PropList.Not_set(
                      cs.cs_name,
                      Some(
                        Printf.sprintf(
                          f_("Executable '%s' not yet built."),
                          cs.cs_name,
                        ),
                      ),
                    ),
                  )
                };
              },
            ),
          );
        }

      | Library(_)
      | Object(_)
      | Flag(_)
      | Test(_)
      | SrcRepo(_)
      | Doc(_) => (),
      pkg.sections,
    );
};

module BaseTest = {
  /* # 22 "src/base/BaseTest.ml" */

  open BaseEnv;
  open BaseMessage;
  open OASISTypes;
  open OASISGettext;

  let test = (~ctxt, lst, pkg, extra_args) => {
    let one_test = ((failure, n), (test_plugin, cs, test)) =>
      if (var_choose(
            ~name=Printf.sprintf(f_("test %s run"), cs.cs_name),
            ~printer=string_of_bool,
            test.test_run,
          )) {
        let () = info(f_("Running test '%s'"), cs.cs_name);
        let back_cwd =
          switch (test.test_working_directory) {
          | Some(dir) =>
            let cwd = Sys.getcwd();
            let chdir = d => {
              info(f_("Changing directory to '%s'"), d);
              Sys.chdir(d);
            };

            chdir(dir);
            (() => chdir(cwd));

          | None => (() => ())
          };

        try (
          {
            let failure_percent =
              BaseCustom.hook(
                test.test_custom,
                test_plugin(~ctxt, pkg, (cs, test)),
                extra_args,
              );

            back_cwd();
            (failure_percent +. failure, n + 1);
          }
        ) {
        | e =>
          back_cwd();
          raise(e);
        };
      } else {
        info(f_("Skipping test '%s'"), cs.cs_name);
        (failure, n);
      };

    let (failed, n) = List.fold_left(one_test, (0.0, 0), lst);
    let failure_percent =
      if (n == 0) {
        0.0;
      } else {
        failed /. float_of_int(n);
      };
    let msg =
      Printf.sprintf(
        f_("Tests had a %.2f%% failure rate"),
        100. *. failure_percent,
      );

    if (failure_percent > 0.0) {
      failwith(msg);
    } else {
      info("%s", msg);
    };

    /* Possible explanation why the tests where not run. */
    if (OASISFeatures.package_test(OASISFeatures.flag_tests, pkg)
        && !bool_of_string(BaseStandardVar.tests())
        && lst != []) {
      BaseMessage.warning(
        "Tests are turned off, consider enabling with 'ocaml setup.ml -configure --enable-tests'",
      );
    };
  };
};

module BaseDoc = {
  /* # 22 "src/base/BaseDoc.ml" */

  open BaseEnv;
  open BaseMessage;
  open OASISTypes;
  open OASISGettext;

  let doc = (~ctxt, lst, pkg, extra_args) => {
    let one_doc = ((doc_plugin, cs, doc)) =>
      if (var_choose(
            ~name=Printf.sprintf(f_("documentation %s build"), cs.cs_name),
            ~printer=string_of_bool,
            doc.doc_build,
          )) {
        info(f_("Building documentation '%s'"), cs.cs_name);
        BaseCustom.hook(
          doc.doc_custom,
          doc_plugin(~ctxt, pkg, (cs, doc)),
          extra_args,
        );
      };

    List.iter(one_doc, lst);

    if (OASISFeatures.package_test(OASISFeatures.flag_docs, pkg)
        && !bool_of_string(BaseStandardVar.docs())
        && lst != []) {
      BaseMessage.warning(
        "Docs are turned off, consider enabling with 'ocaml setup.ml -configure --enable-docs'",
      );
    };
  };
};

module BaseSetup = {
  /* # 22 "src/base/BaseSetup.ml" */

  open OASISContext;
  open BaseEnv;
  open BaseMessage;
  open OASISTypes;
  open OASISGettext;
  open OASISUtils;

  type std_args_fun = (~ctxt: OASISContext.t, package, array(string)) => unit;

  type section_args_fun('a, 'b) = (
    name,
    (~ctxt: OASISContext.t, package, (common_section, 'a), array(string)) =>
    'b,
  );

  type t = {
    configure: std_args_fun,
    build: std_args_fun,
    doc: list(section_args_fun(doc, unit)),
    test: list(section_args_fun(test, float)),
    install: std_args_fun,
    uninstall: std_args_fun,
    clean: list(std_args_fun),
    clean_doc: list(section_args_fun(doc, unit)),
    clean_test: list(section_args_fun(test, unit)),
    distclean: list(std_args_fun),
    distclean_doc: list(section_args_fun(doc, unit)),
    distclean_test: list(section_args_fun(test, unit)),
    package,
    oasis_fn: option(string),
    oasis_version: string,
    oasis_digest: option(Digest.t),
    oasis_exec: option(string),
    oasis_setup_args: list(string),
    setup_update: bool,
  };

  /* Associate a plugin function with data from package */
  let join_plugin_sections = (filter_map, lst) =>
    List.rev(
      List.fold_left(
        (acc, sct) =>
          switch (filter_map(sct)) {
          | Some(e) => [e, ...acc]
          | None => acc
          },
        [],
        lst,
      ),
    );

  /* Search for plugin data associated with a section name */
  let lookup_plugin_section = (plugin, action, nm, lst) =>
    try (List.assoc(nm, lst)) {
    | Not_found =>
      failwithf(
        f_("Cannot find plugin %s matching section %s for %s action"),
        plugin,
        nm,
        action,
      )
    };

  let configure = (~ctxt, t, args) => {
    /* Run configure */
    BaseCustom.hook(
      t.package.conf_custom,
      () => {
        /* Reload if preconf has changed it */
        try (
          {
            unload();
            load(~ctxt, ());
          }
        ) {
        | _ => ()
        };

        /* Run plugin's configure */
        t.configure(~ctxt, t.package, args);

        /* Dump to allow postconf to change it */
        dump(~ctxt, ());
      },
      (),
    );

    /* Reload environment */
    unload();
    load(~ctxt, ());

    /* Save environment */
    print();

    /* Replace data in file */
    BaseFileAB.replace(~ctxt, t.package.files_ab);
  };

  let build = (~ctxt, t, args) =>
    BaseCustom.hook(t.package.build_custom, t.build(~ctxt, t.package), args);

  let doc = (~ctxt, t, args) =>
    BaseDoc.doc(
      ~ctxt,
      join_plugin_sections(
        fun
        | [@implicit_arity] Doc(cs, e) =>
          Some((
            lookup_plugin_section(
              "documentation",
              s_("build"),
              cs.cs_name,
              t.doc,
            ),
            cs,
            e,
          ))
        | _ => None,
        t.package.sections,
      ),
      t.package,
      args,
    );

  let test = (~ctxt, t, args) =>
    BaseTest.test(
      ~ctxt,
      join_plugin_sections(
        fun
        | [@implicit_arity] Test(cs, e) =>
          Some((
            lookup_plugin_section("test", s_("run"), cs.cs_name, t.test),
            cs,
            e,
          ))
        | _ => None,
        t.package.sections,
      ),
      t.package,
      args,
    );

  let all = (~ctxt, t, args) => {
    let rno_doc = ref(false);
    let rno_test = ref(false);
    let arg_rest = ref([]);
    Arg.parse_argv(
      ~current=ref(0),
      Array.of_list([Sys.executable_name ++ " all", ...Array.to_list(args)]),
      [
        ("-no-doc", Arg.Set(rno_doc), s_("Don't run doc target")),
        ("-no-test", Arg.Set(rno_test), s_("Don't run test target")),
        (
          "--",
          Arg.Rest(arg => arg_rest := [arg, ...arg_rest^]),
          s_("All arguments for configure."),
        ),
      ],
      failwithf(f_("Don't know what to do with '%s'")),
      "",
    );

    info("Running configure step");
    configure(~ctxt, t, Array.of_list(List.rev(arg_rest^)));

    info("Running build step");
    build(~ctxt, t, [||]);

    /* Load setup.log dynamic variables */
    BaseDynVar.init(~ctxt, t.package);

    if (! rno_doc^) {
      info("Running doc step");
      doc(~ctxt, t, [||]);
    } else {
      info("Skipping doc step");
    };
    if (! rno_test^) {
      info("Running test step");
      test(~ctxt, t, [||]);
    } else {
      info("Skipping test step");
    };
  };

  let install = (~ctxt, t, args) =>
    BaseCustom.hook(
      t.package.install_custom,
      t.install(~ctxt, t.package),
      args,
    );

  let uninstall = (~ctxt, t, args) =>
    BaseCustom.hook(
      t.package.uninstall_custom,
      t.uninstall(~ctxt, t.package),
      args,
    );

  let reinstall = (~ctxt, t, args) => {
    uninstall(~ctxt, t, args);
    install(~ctxt, t, args);
  };

  let (clean, distclean) = {
    let failsafe = (f, a) =>
      try (f(a)) {
      | e =>
        warning(
          f_("Action fail with error: %s"),
          switch (e) {
          | Failure(msg) => msg
          | e => Printexc.to_string(e)
          },
        )
      };

    let generic_clean = (~ctxt, t, cstm, mains, docs, tests, args) =>
      BaseCustom.hook(
        ~failsafe=true,
        cstm,
        () => {
          /* Clean section */
          List.iter(
            fun
            | [@implicit_arity] Test(cs, test) => {
                let f =
                  try (List.assoc(cs.cs_name, tests)) {
                  | Not_found => ((~ctxt as _, _, _, _) => ())
                  };

                failsafe(f(~ctxt, t.package, (cs, test)), args);
              }
            | [@implicit_arity] Doc(cs, doc) => {
                let f =
                  try (List.assoc(cs.cs_name, docs)) {
                  | Not_found => ((~ctxt as _, _, _, _) => ())
                  };

                failsafe(f(~ctxt, t.package, (cs, doc)), args);
              }
            | Library(_)
            | Object(_)
            | Executable(_)
            | Flag(_)
            | SrcRepo(_) => (),
            t.package.sections,
          );
          /* Clean whole package */
          List.iter(f => failsafe(f(~ctxt, t.package), args), mains);
        },
        (),
      );

    let clean = (~ctxt, t, args) =>
      generic_clean(
        ~ctxt,
        t,
        t.package.clean_custom,
        t.clean,
        t.clean_doc,
        t.clean_test,
        args,
      );

    let distclean = (~ctxt, t, args) => {
      /* Call clean */
      clean(~ctxt, t, args);

      /* Call distclean code */
      generic_clean(
        ~ctxt,
        t,
        t.package.distclean_custom,
        t.distclean,
        t.distclean_doc,
        t.distclean_test,
        args,
      );

      /* Remove generated source files. */
      List.iter(
        fn =>
          if ((ctxt.srcfs)#file_exists(fn)) {
            info(f_("Remove '%s'"), (ctxt.srcfs)#string_of_filename(fn));
            (ctxt.srcfs)#remove(fn);
          },
        [BaseEnv.default_filename, BaseLog.default_filename]
        @ List.rev_map(BaseFileAB.to_filename, t.package.files_ab),
      );
    };

    (clean, distclean);
  };

  let version = (~ctxt as _, t: t, _) => print_endline(t.oasis_version);

  let (update_setup_ml, no_update_setup_ml_cli) = {
    let b = ref(true);
    (
      b,
      (
        "-no-update-setup-ml",
        Arg.Clear(b),
        s_(" Don't try to update setup.ml, even if _oasis has changed."),
      ),
    );
  };

  /* TODO: srcfs */
  let default_oasis_fn = "_oasis";

  let update_setup_ml = t => {
    let oasis_fn =
      switch (t.oasis_fn) {
      | Some(fn) => fn
      | None => default_oasis_fn
      };

    let oasis_exec =
      switch (t.oasis_exec) {
      | Some(fn) => fn
      | None => "oasis"
      };

    let ocaml = Sys.executable_name;

    let (setup_ml, args) =
      switch (Array.to_list(Sys.argv)) {
      | [setup_ml, ...args] => (setup_ml, args)
      | [] => failwith(s_("Expecting non-empty command line arguments."))
      };

    let (ocaml, setup_ml) =
      if (Sys.executable_name == Sys.argv[0]) {
        /* We are not running in standard mode, probably the script
          * is precompiled.
         */
        ("ocaml", "setup.ml");
      } else {
        (ocaml, setup_ml);
      };

    let (no_update_setup_ml_cli, _, _) = no_update_setup_ml_cli;
    let do_update = () => {
      let oasis_exec_version =
        OASISExec.run_read_one_line(
          ~ctxt=BaseContext.default^,
          ~f_exit_code=
            fun
            | 0 => ()
            | 1 =>
              failwithf(
                f_(
                  "Executable '%s' is probably an old version of oasis (< 0.3.0), please update to version v%s.",
                ),
                oasis_exec,
                t.oasis_version,
              )
            | 127 =>
              failwithf(
                f_("Cannot find executable '%s', please install oasis v%s."),
                oasis_exec,
                t.oasis_version,
              )
            | n =>
              failwithf(
                f_("Command '%s version' exited with code %d."),
                oasis_exec,
                n,
              ),
          oasis_exec,
          ["version"],
        );

      if (OASISVersion.comparator_apply(
            OASISVersion.version_of_string(oasis_exec_version),
            OASISVersion.VGreaterEqual(
              OASISVersion.version_of_string(t.oasis_version),
            ),
          )) {
        /* We have a version >= for the executable oasis, proceed with
          * update.
         */
        /* TODO: delegate this check to 'oasis setup'. */
        if (Sys.os_type == "Win32") {
          failwithf(
            f_(
              "It is not possible to update the running script setup.ml on Windows. Please update setup.ml by running '%s'.",
            ),
            String.concat(" ", [oasis_exec, "setup", ...t.oasis_setup_args]),
          );
        } else {
          OASISExec.run(
            ~ctxt=BaseContext.default^,
            ~f_exit_code=
              n =>
                if (n != 0) {
                  failwithf(
                    f_(
                      "Unable to update setup.ml using '%s', please fix the problem and retry.",
                    ),
                    oasis_exec,
                  );
                },
            oasis_exec,
            ["setup", ...t.oasis_setup_args],
          );
          OASISExec.run(
            ~ctxt=BaseContext.default^,
            ocaml,
            [setup_ml, ...args],
          );
        };
      } else {
        failwithf(
          f_(
            "The version of '%s' (v%s) doesn't match the version of oasis used to generate the %s file. Please install at least oasis v%s.",
          ),
          oasis_exec,
          oasis_exec_version,
          setup_ml,
          t.oasis_version,
        );
      };
    };

    if (update_setup_ml^) {
      try (
        switch (t.oasis_digest) {
        | Some(dgst) =>
          if (Sys.file_exists(oasis_fn)
              && dgst != Digest.file(default_oasis_fn)) {
            do_update();
            true;
          } else {
            false;
          }
        | None => false
        }
      ) {
      | e =>
        error(
          f_(
            "Error when updating setup.ml. If you want to avoid this error, you can bypass the update of %s by running '%s %s %s %s'",
          ),
          setup_ml,
          ocaml,
          setup_ml,
          no_update_setup_ml_cli,
          String.concat(" ", args),
        );
        raise(e);
      };
    } else {
      false;
    };
  };

  let setup = t => {
    let catch_exn = ref(true);
    let act_ref =
      ref((~ctxt as _, _) =>
        failwithf(
          f_("No action defined, run '%s %s -help'"),
          Sys.executable_name,
          Sys.argv[0],
        )
      );

    let extra_args_ref = ref([]);
    let allow_empty_env_ref = ref(false);
    let arg_handle = (~allow_empty_env=false, act) =>
      Arg.Tuple([
        Arg.Rest(str => extra_args_ref := [str, ...extra_args_ref^]),
        Arg.Unit(
          () => {
            allow_empty_env_ref := allow_empty_env;
            act_ref := act;
          },
        ),
      ]);

    try (
      {
        let () =
          Arg.parse(
            Arg.align(
              [
                (
                  "-configure",
                  arg_handle(~allow_empty_env=true, configure),
                  s_("[options*] Configure the whole build process."),
                ),
                (
                  "-build",
                  arg_handle(build),
                  s_("[options*] Build executables and libraries."),
                ),
                (
                  "-doc",
                  arg_handle(doc),
                  s_("[options*] Build documents."),
                ),
                ("-test", arg_handle(test), s_("[options*] Run tests.")),
                (
                  "-all",
                  arg_handle(~allow_empty_env=true, all),
                  s_(
                    "[options*] Run configure, build, doc and test targets.",
                  ),
                ),
                (
                  "-install",
                  arg_handle(install),
                  s_(
                    "[options*] Install libraries, data, executables and documents.",
                  ),
                ),
                (
                  "-uninstall",
                  arg_handle(uninstall),
                  s_(
                    "[options*] Uninstall libraries, data, executables and documents.",
                  ),
                ),
                (
                  "-reinstall",
                  arg_handle(reinstall),
                  s_(
                    "[options*] Uninstall and install libraries, data, executables and documents.",
                  ),
                ),
                (
                  "-clean",
                  arg_handle(~allow_empty_env=true, clean),
                  s_("[options*] Clean files generated by a build."),
                ),
                (
                  "-distclean",
                  arg_handle(~allow_empty_env=true, distclean),
                  s_(
                    "[options*] Clean files generated by a build and configure.",
                  ),
                ),
                (
                  "-version",
                  arg_handle(~allow_empty_env=true, version),
                  s_(
                    " Display version of OASIS used to generate this setup.ml.",
                  ),
                ),
                (
                  "-no-catch-exn",
                  Arg.Clear(catch_exn),
                  s_(" Don't catch exception, useful for debugging."),
                ),
              ]
              @ (
                if (t.setup_update) {
                  [no_update_setup_ml_cli];
                } else {
                  [];
                }
              )
              @ BaseContext.args(),
            ),
            failwithf(f_("Don't know what to do with '%s'")),
            s_("Setup and run build process current package\n"),
          );

        /* Instantiate the context. */
        let ctxt = BaseContext.default^;

        /* Build initial environment */
        load(~ctxt, ~allow_empty=allow_empty_env_ref^, ());

        /*** Initialize flags */
        List.iter(
          fun
          | [@implicit_arity]
            Flag(cs, {flag_description: hlp, flag_default: choices}) => {
              let apply = (~short_desc=?, ()) =>
                var_ignore(
                  var_define(
                    ~cli=CLIEnable,
                    ~short_desc?,
                    OASISUtils.varname_of_string(cs.cs_name),
                    () =>
                    string_of_bool(
                      var_choose(
                        ~name=
                          Printf.sprintf(
                            f_("default value of flag %s"),
                            cs.cs_name,
                          ),
                        ~printer=string_of_bool,
                        choices,
                      ),
                    )
                  ),
                );

              switch (hlp) {
              | Some(hlp) => apply(~short_desc=() => hlp, ())
              | None => apply()
              };
            }
          | _ => (),
          t.package.sections,
        );

        BaseStandardVar.init(t.package);

        BaseDynVar.init(~ctxt, t.package);

        if (!(t.setup_update && update_setup_ml(t))) {
          act_ref^(~ctxt, t, Array.of_list(List.rev(extra_args_ref^)));
        };
      }
    ) {
    | e when catch_exn^ =>
      error("%s", Printexc.to_string(e));
      exit(1);
    };
  };
};

module BaseCompat = {
  /* # 22 "src/base/BaseCompat.ml" */

  /** Compatibility layer to provide a stable API inside setup.ml.
      This layer allows OASIS to change in between minor versions
      (e.g. 0.4.6 -> 0.4.7) but still provides a stable API inside setup.ml. This
      enables to write functions that manipulate setup_t inside setup.ml. See
      deps.ml for an example.

      The module opened by default will depend on the version of the _oasis. E.g.
      if we have "OASISFormat: 0.3", the module Compat_0_3 will be opened and
      the function Compat_0_3 will be called. If setup.ml is generated with the
      -nocompat, no module will be opened.

      @author Sylvain Le Gall
    */;

  module Compat_0_4 = {
    let rctxt = ref(BaseContext.default^);

    module BaseSetup = {
      module Original = BaseSetup;

      open OASISTypes;

      type std_args_fun = (package, array(string)) => unit;
      type section_args_fun('a, 'b) = (
        name,
        (package, (common_section, 'a), array(string)) => 'b,
      );
      type t = {
        configure: std_args_fun,
        build: std_args_fun,
        doc: list(section_args_fun(doc, unit)),
        test: list(section_args_fun(test, float)),
        install: std_args_fun,
        uninstall: std_args_fun,
        clean: list(std_args_fun),
        clean_doc: list(section_args_fun(doc, unit)),
        clean_test: list(section_args_fun(test, unit)),
        distclean: list(std_args_fun),
        distclean_doc: list(section_args_fun(doc, unit)),
        distclean_test: list(section_args_fun(test, unit)),
        package,
        oasis_fn: option(string),
        oasis_version: string,
        oasis_digest: option(Digest.t),
        oasis_exec: option(string),
        oasis_setup_args: list(string),
        setup_update: bool,
      };

      let setup = t => {
        let mk_std_args_fun = (f, ~ctxt, pkg, args) => {
          rctxt := ctxt;
          f(pkg, args);
        };

        let mk_section_args_fun = l =>
          List.map(
            ((nm, f)) => (
              nm,
              (~ctxt, pkg, sct, args) => {
                rctxt := ctxt;
                f(pkg, sct, args);
              },
            ),
            l,
          );

        let t' = {
          Original.configure: mk_std_args_fun(t.configure),
          build: mk_std_args_fun(t.build),
          doc: mk_section_args_fun(t.doc),
          test: mk_section_args_fun(t.test),
          install: mk_std_args_fun(t.install),
          uninstall: mk_std_args_fun(t.uninstall),
          clean: List.map(mk_std_args_fun, t.clean),
          clean_doc: mk_section_args_fun(t.clean_doc),
          clean_test: mk_section_args_fun(t.clean_test),
          distclean: List.map(mk_std_args_fun, t.distclean),
          distclean_doc: mk_section_args_fun(t.distclean_doc),
          distclean_test: mk_section_args_fun(t.distclean_test),
          package: t.package,
          oasis_fn: t.oasis_fn,
          oasis_version: t.oasis_version,
          oasis_digest: t.oasis_digest,
          oasis_exec: t.oasis_exec,
          oasis_setup_args: t.oasis_setup_args,
          setup_update: t.setup_update,
        };

        Original.setup(t');
      };
    };

    let adapt_setup_t = setup_t => {
      module O = BaseSetup.Original;
      let mk_std_args_fun = (f, pkg, args) => f(~ctxt=rctxt^, pkg, args);
      let mk_section_args_fun = l =>
        List.map(
          ((nm, f)) => (
            nm,
            (pkg, sct, args) => f(~ctxt=rctxt^, pkg, sct, args),
          ),
          l,
        );

      {
        BaseSetup.configure: mk_std_args_fun(setup_t.O.configure),
        build: mk_std_args_fun(setup_t.O.build),
        doc: mk_section_args_fun(setup_t.O.doc),
        test: mk_section_args_fun(setup_t.O.test),
        install: mk_std_args_fun(setup_t.O.install),
        uninstall: mk_std_args_fun(setup_t.O.uninstall),
        clean: List.map(mk_std_args_fun, setup_t.O.clean),
        clean_doc: mk_section_args_fun(setup_t.O.clean_doc),
        clean_test: mk_section_args_fun(setup_t.O.clean_test),
        distclean: List.map(mk_std_args_fun, setup_t.O.distclean),
        distclean_doc: mk_section_args_fun(setup_t.O.distclean_doc),
        distclean_test: mk_section_args_fun(setup_t.O.distclean_test),
        package: setup_t.O.package,
        oasis_fn: setup_t.O.oasis_fn,
        oasis_version: setup_t.O.oasis_version,
        oasis_digest: setup_t.O.oasis_digest,
        oasis_exec: setup_t.O.oasis_exec,
        oasis_setup_args: setup_t.O.oasis_setup_args,
        setup_update: setup_t.O.setup_update,
      };
    };
  };

  module Compat_0_3 = {
    include Compat_0_4;
  };
};

module InternalConfigurePlugin = {
  /* # 22 "src/plugins/internal/InternalConfigurePlugin.ml" */

  /** Configure using internal scheme
      @author Sylvain Le Gall
  */;

  open BaseEnv;
  open OASISTypes;
  open OASISUtils;
  open OASISGettext;
  open BaseMessage;

  /** Configure build using provided series of check to be done
      and then output corresponding file.
  */

  let configure = (~ctxt as _, pkg, argv) => {
    let var_ignore_eval = var => {
      let _s: string = var();
      ();
    };
    let errors = ref(SetString.empty);
    let buff = Buffer.create(13);

    let add_errors = fmt =>
      Printf.kbprintf(
        b => {
          errors := SetString.add(Buffer.contents(b), errors^);
          Buffer.clear(b);
        },
        buff,
        fmt,
      );

    let warn_exception = e => warning("%s", Printexc.to_string(e));

    /* Check tools */
    let check_tools = lst =>
      List.iter(
        fun
        | ExternalTool(tool) =>
          try (var_ignore_eval(BaseCheck.prog(tool))) {
          | e =>
            warn_exception(e);
            add_errors(f_("Cannot find external tool '%s'"), tool);
          }
        | InternalExecutable(nm1) =>
          /* Check that matching tool is built */
          List.iter(
            fun
            | [@implicit_arity]
              Executable({cs_name: nm2, _}, {bs_build: build, _}, _)
                when nm1 == nm2 =>
              if (!var_choose(build)) {
                add_errors(
                  f_(
                    "Cannot find buildable internal executable '%s' when checking build depends",
                  ),
                  nm1,
                );
              }
            | _ => (),
            pkg.sections,
          ),
        lst,
      );

    let build_checks = (sct, bs) =>
      if (var_choose(bs.bs_build)) {
        if (bs.bs_compiled_object == Native) {
          try (var_ignore_eval(BaseStandardVar.ocamlopt)) {
          | e =>
            warn_exception(e);
            add_errors(
              f_("Section %s requires native compilation"),
              OASISSection.string_of_section(sct),
            );
          };
        };

        /* Check tools */
        check_tools(bs.bs_build_tools);

        /* Check depends */
        List.iter(
          fun
          | [@implicit_arity] FindlibPackage(findlib_pkg, version_comparator) =>
            try (
              var_ignore_eval(
                BaseCheck.package(~version_comparator?, findlib_pkg),
              )
            ) {
            | e =>
              warn_exception(e);
              switch (version_comparator) {
              | None =>
                add_errors(f_("Cannot find findlib package %s"), findlib_pkg)
              | Some(ver_cmp) =>
                add_errors(
                  f_("Cannot find findlib package %s (%s)"),
                  findlib_pkg,
                  OASISVersion.string_of_comparator(ver_cmp),
                )
              };
            }
          | InternalLibrary(nm1) =>
            /* Check that matching library is built */
            List.iter(
              fun
              | [@implicit_arity]
                Library({cs_name: nm2, _}, {bs_build: build, _}, _)
                  when nm1 == nm2 =>
                if (!var_choose(build)) {
                  add_errors(
                    f_(
                      "Cannot find buildable internal library '%s' when checking build depends",
                    ),
                    nm1,
                  );
                }
              | _ => (),
              pkg.sections,
            ),
          bs.bs_build_depends,
        );
      };

    /* Parse command line */
    BaseArgExt.parse(argv, BaseEnv.args());

    /* OCaml version */
    switch (pkg.ocaml_version) {
    | Some(ver_cmp) =>
      try (
        var_ignore_eval(
          BaseCheck.version("ocaml", ver_cmp, BaseStandardVar.ocaml_version),
        )
      ) {
      | e =>
        warn_exception(e);
        add_errors(
          f_("OCaml version %s doesn't match version constraint %s"),
          BaseStandardVar.ocaml_version(),
          OASISVersion.string_of_comparator(ver_cmp),
        );
      }
    | None => ()
    };

    /* Findlib version */
    switch (pkg.findlib_version) {
    | Some(ver_cmp) =>
      try (
        var_ignore_eval(
          BaseCheck.version(
            "findlib",
            ver_cmp,
            BaseStandardVar.findlib_version,
          ),
        )
      ) {
      | e =>
        warn_exception(e);
        add_errors(
          f_("Findlib version %s doesn't match version constraint %s"),
          BaseStandardVar.findlib_version(),
          OASISVersion.string_of_comparator(ver_cmp),
        );
      }
    | None => ()
    };
    {
      /* Make sure the findlib version is fine for the OCaml compiler. */

      let ocaml_ge4 =
        OASISVersion.version_compare(
          OASISVersion.version_of_string(BaseStandardVar.ocaml_version()),
          OASISVersion.version_of_string("4.0.0"),
        )
        >= 0;
      if (ocaml_ge4) {
        let findlib_lt132 =
          OASISVersion.version_compare(
            OASISVersion.version_of_string(BaseStandardVar.findlib_version()),
            OASISVersion.version_of_string("1.3.2"),
          )
          < 0;
        if (findlib_lt132) {
          add_errors("OCaml >= 4.0.0 requires Findlib version >= 1.3.2");
        };
      };
    };

    /* FlexDLL */
    if (BaseStandardVar.os_type() == "Win32"
        || BaseStandardVar.os_type() == "Cygwin") {
      try (var_ignore_eval(BaseStandardVar.flexlink)) {
      | e =>
        warn_exception(e);
        add_errors(f_("Cannot find 'flexlink'"));
      };
    };

    /* Check build depends */
    List.iter(
      fun
      | (
          [@implicit_arity] Executable(_, bs, _) |
          [@implicit_arity] Library(_, bs, _)
        ) as sct =>
        build_checks(sct, bs)
      | [@implicit_arity] Doc(_, doc) =>
        if (var_choose(doc.doc_build)) {
          check_tools(doc.doc_build_tools);
        }
      | [@implicit_arity] Test(_, test) =>
        if (var_choose(test.test_run)) {
          check_tools(test.test_tools);
        }
      | _ => (),
      pkg.sections,
    );

    /* Check if we need native dynlink (presence of libraries that compile to
          native)
       */
    {
      let has_cmxa =
        List.exists(
          fun
          | [@implicit_arity] Library(_, bs, _) =>
            var_choose(bs.bs_build)
            && (
              bs.bs_compiled_object == Native
              || bs.bs_compiled_object == Best
              && bool_of_string(BaseStandardVar.is_native())
            )
          | _ => false,
          pkg.sections,
        );

      if (has_cmxa) {
        var_ignore_eval(BaseStandardVar.native_dynlink);
      };
    };

    /* Check errors */
    if (SetString.empty !== errors^) {
      List.iter(e => error("%s", e), SetString.elements(errors^));
      failwithf(
        fn_(
          "%d configuration error",
          "%d configuration errors",
          SetString.cardinal(errors^),
        ),
        SetString.cardinal(errors^),
      );
    };
  };
};

module InternalInstallPlugin = {
  /* # 22 "src/plugins/internal/InternalInstallPlugin.ml" */

  /** Install using internal scheme
      @author Sylvain Le Gall
    */;

  /* TODO: rewrite this module with OASISFileSystem. */

  open BaseEnv;
  open BaseStandardVar;
  open BaseMessage;
  open OASISTypes;
  open OASISFindlib;
  open OASISGettext;
  open OASISUtils;

  let exec_hook = ref(((cs, bs, exec)) => (cs, bs, exec));
  let lib_hook = ref(((cs, bs, dn, lib)) => (cs, bs, dn, lib, []));
  let obj_hook = ref(((cs, bs, dn, obj)) => (cs, bs, dn, obj, []));
  let doc_hook = ref(((cs, doc)) => (cs, doc));

  let install_file_ev = "install-file";
  let install_dir_ev = "install-dir";
  let install_findlib_ev = "install-findlib";

  /* TODO: this can be more generic and used elsewhere. */
  let win32_max_command_line_length = 8000;

  let split_install_command = (ocamlfind, findlib_name, meta, files) =>
    if (Sys.os_type == "Win32") {
      /* Arguments for the first command: */
      let first_args = ["install", findlib_name, meta];
      /* Arguments for remaining commands: */
      let other_args = ["install", findlib_name, "-add"];
      /* Extract as much files as possible from [files], [len] is
         the current command line length: */
      let rec get_files = (len, acc, files) =>
        switch (files) {
        | [] => (List.rev(acc), [])
        | [file, ...rest] =>
          let len = len + 1 + String.length(file);
          if (len > win32_max_command_line_length) {
            (List.rev(acc), files);
          } else {
            get_files(len, [file, ...acc], rest);
          };
        };

      /* Split the command into several commands. */
      let rec split = (args, files) =>
        switch (files) {
        | [] => []
        | _ =>
          /* Length of "ocamlfind install <lib> [META|-add]" */
          let len =
            List.fold_left(
              (len, arg) => len + 1 /* for the space */ + String.length(arg),
              String.length(ocamlfind),
              args,
            );

          switch (get_files(len, [], files)) {
          | ([], _) => failwith(s_("Command line too long."))
          | (firsts, others) =>
            let cmd = args @ firsts;
            /* Use -add for remaining commands: */
            let () = {
              let findlib_ge_132 =
                OASISVersion.comparator_apply(
                  OASISVersion.version_of_string(
                    BaseStandardVar.findlib_version(),
                  ),
                  OASISVersion.VGreaterEqual(
                    OASISVersion.version_of_string("1.3.2"),
                  ),
                );

              if (!findlib_ge_132) {
                failwithf(
                  f_(
                    "Installing the library %s require to use the flag '-add' of ocamlfind because the command line is too long. This flag is only available for findlib 1.3.2. Please upgrade findlib from %s to 1.3.2",
                  ),
                  findlib_name,
                  BaseStandardVar.findlib_version(),
                );
              };
            };

            let cmds = split(other_args, others);
            [cmd, ...cmds];
          };
        };

      /* The first command does not use -add: */
      split(first_args, files);
    } else {
      [["install", findlib_name, meta, ...files]];
    };

  let install = {
    let in_destdir = fn =>
      /* Practically speaking destdir is prepended at the beginning of the
            target filename
         */
      try (destdir() ++ fn) {
      | PropList.Not_set(_) => fn
      };

    let install_file =
        (~ctxt, ~prepend_destdir=true, ~tgt_fn=?, src_file, envdir) => {
      let tgt_dir =
        if (prepend_destdir) {
          in_destdir(envdir());
        } else {
          envdir();
        };

      let tgt_file =
        Filename.concat(
          tgt_dir,
          switch (tgt_fn) {
          | Some(fn) => fn
          | None => Filename.basename(src_file)
          },
        );

      /* Create target directory if needed */
      OASISFileUtil.mkdir_parent(
        ~ctxt,
        dn => {
          info(f_("Creating directory '%s'"), dn);
          BaseLog.register(~ctxt, install_dir_ev, dn);
        },
        Filename.dirname(tgt_file),
      );

      /* Really install files */
      info(f_("Copying file '%s' to '%s'"), src_file, tgt_file);
      OASISFileUtil.cp(~ctxt, src_file, tgt_file);
      BaseLog.register(~ctxt, install_file_ev, tgt_file);
    };

    /* Install the files for a library. */

    let install_lib_files = (~ctxt, findlib_name, files) => {
      let findlib_dir = {
        let dn = {
          let findlib_destdir =
            OASISExec.run_read_one_line(
              ~ctxt,
              ocamlfind(),
              ["printconf", "destdir"],
            );

          Filename.concat(findlib_destdir, findlib_name);
        };

        () => dn;
      };

      let () =
        if (!OASISFileUtil.file_exists_case(findlib_dir())) {
          failwithf(
            f_("Directory '%s' doesn't exist for findlib library %s"),
            findlib_dir(),
            findlib_name,
          );
        };

      let f = (dir, file) => {
        let basename = Filename.basename(file);
        let tgt_fn = Filename.concat(dir, basename);
        /* Destdir is already include in printconf. */
        install_file(
          ~ctxt,
          ~prepend_destdir=false,
          ~tgt_fn,
          file,
          findlib_dir,
        );
      };

      List.iter(((dir, files)) => List.iter(f(dir), files), files);
    };

    /* Install data into defined directory */
    let install_data = (~ctxt, srcdir, lst, tgtdir) => {
      let tgtdir = OASISHostPath.of_unix(var_expand(tgtdir));

      List.iter(
        ((src, tgt_opt)) => {
          let real_srcs =
            OASISFileUtil.glob(
              ~ctxt=BaseContext.default^,
              Filename.concat(srcdir, src),
            );

          if (real_srcs == []) {
            failwithf(f_("Wildcard '%s' doesn't match any files"), src);
          };
          List.iter(
            fn =>
              install_file(~ctxt, fn, () =>
                switch (tgt_opt) {
                | Some(s) => OASISHostPath.of_unix(var_expand(s))
                | None => tgtdir
                }
              ),
            real_srcs,
          );
        },
        lst,
      );
    };

    let make_fnames = (modul, sufx) =>
      List.fold_right(
        (sufx, accu) => [
          OASISString.capitalize_ascii(modul) ++ sufx,
          OASISString.uncapitalize_ascii(modul) ++ sufx,
          ...accu,
        ],
        sufx,
        [],
      );

    /*** Install all libraries */
    let install_libs = (~ctxt, pkg) => {
      let find_first_existing_files_in_path = (bs, lst) => {
        let path = OASISHostPath.of_unix(bs.bs_path);
        List.find(
          OASISFileUtil.file_exists_case,
          List.map(Filename.concat(path), lst),
        );
      };

      let files_of_modules = (new_files, typ, cs, bs, modules) =>
        List.fold_left(
          (acc, modul) =>
            (
              /* Add uncompiled header from the source tree */
              try (
                [
                  find_first_existing_files_in_path(
                    bs,
                    make_fnames(modul, [".mli", ".ml"]),
                  ),
                ]
              ) {
              | Not_found =>
                warning(
                  f_("Cannot find source header for module %s in %s %s"),
                  typ,
                  modul,
                  cs.cs_name,
                );
                [];
              }
            )
            @ List.fold_left(
                (acc, fn) =>
                  try (
                    [find_first_existing_files_in_path(bs, [fn]), ...acc]
                  ) {
                  | Not_found => acc
                  },
                acc,
                make_fnames(modul, [".annot", ".cmti", ".cmt"]),
              ),
          new_files,
          modules,
        );

      let files_of_build_section = ((f_data, new_files), typ, cs, bs) => {
        let extra_files =
          List.map(
            fn =>
              try (find_first_existing_files_in_path(bs, [fn])) {
              | Not_found =>
                failwithf(
                  f_("Cannot find extra findlib file %S in %s %s "),
                  fn,
                  typ,
                  cs.cs_name,
                )
              },
            bs.bs_findlib_extra_files,
          );

        let f_data = () => {
          /* Install data associated with the library */
          install_data(
            ~ctxt,
            bs.bs_path,
            bs.bs_data_files,
            Filename.concat(datarootdir(), pkg.name),
          );
          f_data();
        };

        (f_data, new_files @ extra_files);
      };

      let files_of_library = ((f_data, acc), data_lib) => {
        let (cs, bs, lib, dn, lib_extra) = lib_hook^(data_lib);
        if (var_choose(bs.bs_install)
            && BaseBuilt.is_built(~ctxt, BaseBuilt.BLib, cs.cs_name)) {
          /* Start with lib_extra */
          let new_files = lib_extra;
          let new_files =
            files_of_modules(new_files, "library", cs, bs, lib.lib_modules);

          let (f_data, new_files) =
            files_of_build_section((f_data, new_files), "library", cs, bs);

          let new_files =
            /* Get generated files */
            BaseBuilt.fold(
              ~ctxt,
              BaseBuilt.BLib,
              cs.cs_name,
              (acc, fn) => [fn, ...acc],
              new_files,
            );

          let acc = [(dn, new_files), ...acc];

          let f_data = () => {
            /* Install data associated with the library */
            install_data(
              ~ctxt,
              bs.bs_path,
              bs.bs_data_files,
              Filename.concat(datarootdir(), pkg.name),
            );
            f_data();
          };

          (f_data, acc);
        } else {
          (f_data, acc);
        };
      }
      and files_of_object = ((f_data, acc), data_obj) => {
        let (cs, bs, obj, dn, obj_extra) = obj_hook^(data_obj);
        if (var_choose(bs.bs_install)
            && BaseBuilt.is_built(~ctxt, BaseBuilt.BObj, cs.cs_name)) {
          /* Start with obj_extra */
          let new_files = obj_extra;
          let new_files =
            files_of_modules(new_files, "object", cs, bs, obj.obj_modules);

          let (f_data, new_files) =
            files_of_build_section((f_data, new_files), "object", cs, bs);

          let new_files =
            /* Get generated files */
            BaseBuilt.fold(
              ~ctxt,
              BaseBuilt.BObj,
              cs.cs_name,
              (acc, fn) => [fn, ...acc],
              new_files,
            );

          let acc = [(dn, new_files), ...acc];

          let f_data = () => {
            /* Install data associated with the object */
            install_data(
              ~ctxt,
              bs.bs_path,
              bs.bs_data_files,
              Filename.concat(datarootdir(), pkg.name),
            );
            f_data();
          };

          (f_data, acc);
        } else {
          (f_data, acc);
        };
      };

      /* Install one group of library */
      let install_group_lib = grp => {
        /* Iterate through all group nodes */
        let rec install_group_lib_aux = (data_and_files, grp) => {
          let (data_and_files, children) =
            switch (grp) {
            | [@implicit_arity] Container(_, children) => (
                data_and_files,
                children,
              )
            | [@implicit_arity]
              Package(_, cs, bs, `Library(lib), dn, children) => (
                files_of_library(data_and_files, (cs, bs, lib, dn)),
                children,
              )
            | [@implicit_arity] Package(_, cs, bs, `Object(obj), dn, children) => (
                files_of_object(data_and_files, (cs, bs, obj, dn)),
                children,
              )
            };

          List.fold_left(install_group_lib_aux, data_and_files, children);
        };

        /* Findlib name of the root library */
        let findlib_name = findlib_of_group(grp);

        /* Determine root library */
        let root_lib = root_of_group(grp);

        /* All files to install for this library */
        let (f_data, files) = install_group_lib_aux((ignore, []), grp);

        /* Really install, if there is something to install */
        if (files == []) {
          warning(
            f_("Nothing to install for findlib library '%s'"),
            findlib_name,
          );
        } else {
          let meta = {
            /* Search META file */
            let (_, bs, _) = root_lib;
            let res = Filename.concat(bs.bs_path, "META");
            if (!OASISFileUtil.file_exists_case(res)) {
              failwithf(
                f_("Cannot find file '%s' for findlib library %s"),
                res,
                findlib_name,
              );
            };
            res;
          };

          let files = {
            /* Make filename shorter to avoid hitting command max line length
              * too early, esp. on Windows.
             */
            /* TODO: move to OASISHostPath as make_relative. */
            let remove_prefix = (p, n) => {
              let plen = String.length(p);
              let nlen = String.length(n);
              if (plen <= nlen && String.sub(n, 0, plen) == p) {
                let fn_sep =
                  if (Sys.os_type == "Win32") {
                    '\\';
                  } else {
                    '/';
                  };
                let cutpoint =
                  plen
                  + (
                    if (plen < nlen && n.[plen] == fn_sep) {
                      1;
                    } else {
                      0;
                    }
                  );

                String.sub(n, cutpoint, nlen - cutpoint);
              } else {
                n;
              };
            };

            List.map(
              ((dir, fn)) => (
                dir,
                List.map(remove_prefix(Sys.getcwd()), fn),
              ),
              files,
            );
          };

          let ocamlfind = ocamlfind();
          let (nodir_files, dir_files) =
            List.fold_left(
              ((nodir, dir), (dn, lst)) =>
                switch (dn) {
                | Some(dn) => (nodir, [(dn, lst), ...dir])
                | None => (lst @ nodir, dir)
                },
              ([], []),
              List.rev(files),
            );

          info(f_("Installing findlib library '%s'"), findlib_name);
          List.iter(
            OASISExec.run(~ctxt, ocamlfind),
            split_install_command(ocamlfind, findlib_name, meta, nodir_files),
          );
          install_lib_files(~ctxt, findlib_name, dir_files);
          BaseLog.register(~ctxt, install_findlib_ev, findlib_name);
        };

        /* Install data files */
        f_data();
      };

      let (group_libs, _, _) = findlib_mapping(pkg);

      /* We install libraries in groups */
      List.iter(install_group_lib, group_libs);
    };

    let install_execs = (~ctxt, pkg) => {
      let install_exec = data_exec => {
        let (cs, bs, _) = exec_hook^(data_exec);
        if (var_choose(bs.bs_install)
            && BaseBuilt.is_built(~ctxt, BaseBuilt.BExec, cs.cs_name)) {
          let exec_libdir = () => Filename.concat(libdir(), pkg.name);
          BaseBuilt.fold(
            ~ctxt,
            BaseBuilt.BExec,
            cs.cs_name,
            ((), fn) =>
              install_file(
                ~ctxt,
                ~tgt_fn=cs.cs_name ++ ext_program(),
                fn,
                bindir,
              ),
            (),
          );
          BaseBuilt.fold(
            ~ctxt,
            BaseBuilt.BExecLib,
            cs.cs_name,
            ((), fn) => install_file(~ctxt, fn, exec_libdir),
            (),
          );
          install_data(
            ~ctxt,
            bs.bs_path,
            bs.bs_data_files,
            Filename.concat(datarootdir(), pkg.name),
          );
        };
      };

      List.iter(
        fun
        | [@implicit_arity] Executable(cs, bs, exec) =>
          install_exec((cs, bs, exec))
        | _ => (),
        pkg.sections,
      );
    };

    let install_docs = (~ctxt, pkg) => {
      let install_doc = data => {
        let (cs, doc) = doc_hook^(data);
        if (var_choose(doc.doc_install)
            && BaseBuilt.is_built(~ctxt, BaseBuilt.BDoc, cs.cs_name)) {
          let tgt_dir =
            OASISHostPath.of_unix(var_expand(doc.doc_install_dir));
          BaseBuilt.fold(
            ~ctxt,
            BaseBuilt.BDoc,
            cs.cs_name,
            ((), fn) => install_file(~ctxt, fn, () => tgt_dir),
            (),
          );
          install_data(
            ~ctxt,
            Filename.current_dir_name,
            doc.doc_data_files,
            doc.doc_install_dir,
          );
        };
      };

      List.iter(
        fun
        | [@implicit_arity] Doc(cs, doc) => install_doc((cs, doc))
        | _ => (),
        pkg.sections,
      );
    };

    (~ctxt, pkg, _) => {
      install_libs(~ctxt, pkg);
      install_execs(~ctxt, pkg);
      install_docs(~ctxt, pkg);
    };
  };

  /* Uninstall already installed data */
  let uninstall = (~ctxt, _, _) => {
    let uninstall_aux = ((ev, data)) => {
      if (ev == install_file_ev) {
        if (OASISFileUtil.file_exists_case(data)) {
          info(f_("Removing file '%s'"), data);
          Sys.remove(data);
        } else {
          warning(f_("File '%s' doesn't exist anymore"), data);
        };
      } else if (ev == install_dir_ev) {
        if (Sys.file_exists(data) && Sys.is_directory(data)) {
          if (Sys.readdir(data) == [||]) {
            info(f_("Removing directory '%s'"), data);
            OASISFileUtil.rmdir(~ctxt, data);
          } else {
            warning(
              f_("Directory '%s' is not empty (%s)"),
              data,
              String.concat(", ", Array.to_list(Sys.readdir(data))),
            );
          };
        } else {
          warning(f_("Directory '%s' doesn't exist anymore"), data);
        };
      } else if (ev == install_findlib_ev) {
        info(f_("Removing findlib library '%s'"), data);
        OASISExec.run(~ctxt, ocamlfind(), ["remove", data]);
      } else {
        failwithf(f_("Unknown log event '%s'"), ev);
      };
      BaseLog.unregister(~ctxt, ev, data);
    };

    /* We process event in reverse order */
    List.iter(
      uninstall_aux,
      List.rev(BaseLog.filter(~ctxt, [install_file_ev, install_dir_ev])),
    );
    List.iter(
      uninstall_aux,
      List.rev(BaseLog.filter(~ctxt, [install_findlib_ev])),
    );
  };
};

module OCamlbuildCommon = {
  /* # 22 "src/plugins/ocamlbuild/OCamlbuildCommon.ml" */

  /** Functions common to OCamlbuild build and doc plugin
  */;

  open OASISGettext;
  open BaseEnv;
  open BaseStandardVar;
  open OASISTypes;

  type extra_args = list(string);

  let ocamlbuild_clean_ev = "ocamlbuild-clean";

  let ocamlbuildflags =
    var_define(
      ~short_desc=() => "OCamlbuild additional flags",
      "ocamlbuildflags",
      () => "",
    );

  /** Fix special arguments depending on environment */

  let fix_args = (args, extra_argv) =>
    List.flatten([
      if (os_type() == "Win32") {
        ["-classic-display", "-no-log", "-no-links"];
      } else {
        [];
      },
      if (OASISVersion.comparator_apply(
            OASISVersion.version_of_string(ocaml_version()),
            OASISVersion.VLesser(OASISVersion.version_of_string("3.11.1")),
          )) {
        [
          "-install-lib-dir",
          Filename.concat(standard_library(), "ocamlbuild"),
        ];
      } else {
        [];
      },
      if (!bool_of_string(is_native()) || os_type() == "Win32") {
        ["-byte-plugin"];
      } else {
        [];
      },
      args,
      if (bool_of_string(debug())) {
        ["-tag", "debug"];
      } else {
        [];
      },
      if (bool_of_string(tests())) {
        ["-tag", "tests"];
      } else {
        [];
      },
      if (bool_of_string(profile())) {
        ["-tag", "profile"];
      } else {
        [];
      },
      OASISString.nsplit(ocamlbuildflags(), ' '),
      Array.to_list(extra_argv),
    ]);

  /** Run 'ocamlbuild -clean' if not already done */

  let run_clean = (~ctxt, extra_argv) => {
    let extra_cli = String.concat(" ", Array.to_list(extra_argv));

    /* Run if never called with these args */
    if (!BaseLog.exists(~ctxt, ocamlbuild_clean_ev, extra_cli)) {
      OASISExec.run(~ctxt, ocamlbuild(), fix_args(["-clean"], extra_argv));
      BaseLog.register(~ctxt, ocamlbuild_clean_ev, extra_cli);
      at_exit(() =>
        try (BaseLog.unregister(~ctxt, ocamlbuild_clean_ev, extra_cli)) {
        | _ => ()
        }
      );
    };
  };

  /** Run ocamlbuild, unregister all clean events */

  let run_ocamlbuild = (~ctxt, args, extra_argv) => {
    /* TODO: enforce that target in args must be UNIX encoded i.e. toto/index.html
     */
    OASISExec.run(~ctxt, ocamlbuild(), fix_args(args, extra_argv));
    /* Remove any clean event, we must run it again */
    List.iter(
      ((e, d)) => BaseLog.unregister(~ctxt, e, d),
      BaseLog.filter(~ctxt, [ocamlbuild_clean_ev]),
    );
  };

  /** Determine real build directory */

  let build_dir = extra_argv => {
    let rec search_args = dir =>
      fun
      | ["-build-dir", dir, ...tl] => search_args(dir, tl)
      | [_, ...tl] => search_args(dir, tl)
      | [] => dir;

    search_args("_build", fix_args([], extra_argv));
  };
};

module OCamlbuildPlugin = {
  /* # 22 "src/plugins/ocamlbuild/OCamlbuildPlugin.ml" */

  /** Build using ocamlbuild
      @author Sylvain Le Gall
    */;

  open OASISTypes;
  open OASISGettext;
  open OASISUtils;
  open OASISString;
  open BaseEnv;
  open OCamlbuildCommon;
  open BaseStandardVar;

  let cond_targets_hook = ref(lst => lst);

  let build = (~ctxt, extra_args, pkg, argv) => {
    /* Return the filename in build directory */
    let in_build_dir = fn => Filename.concat(build_dir(argv), fn);

    /* Return the unix filename in host build directory */
    let in_build_dir_of_unix = fn => in_build_dir(OASISHostPath.of_unix(fn));

    let cond_targets =
      List.fold_left(
        acc =>
          fun
          | [@implicit_arity] Library(cs, bs, lib)
              when var_choose(bs.bs_build) => {
              let (evs, unix_files) =
                BaseBuilt.of_library(in_build_dir_of_unix, (cs, bs, lib));

              let tgts =
                List.flatten(
                  List.filter(
                    l => l != [],
                    List.map(
                      List.filter(fn =>
                        ends_with(~what=".cma", fn)
                        || ends_with(~what=".cmxs", fn)
                        || ends_with(~what=".cmxa", fn)
                        || ends_with(~what=ext_lib(), fn)
                        || ends_with(~what=ext_dll(), fn)
                      ),
                      unix_files,
                    ),
                  ),
                );

              switch (tgts) {
              | [_, ..._] => [(evs, tgts), ...acc]
              | [] =>
                failwithf(
                  f_("No possible ocamlbuild targets for library %s"),
                  cs.cs_name,
                )
              };
            }

          | [@implicit_arity] Object(cs, bs, obj)
              when var_choose(bs.bs_build) => {
              let (evs, unix_files) =
                BaseBuilt.of_object(in_build_dir_of_unix, (cs, bs, obj));

              let tgts =
                List.flatten(
                  List.filter(
                    l => l != [],
                    List.map(
                      List.filter(fn =>
                        ends_with(~what=".cmo", fn)
                        || ends_with(~what=".cmx", fn)
                      ),
                      unix_files,
                    ),
                  ),
                );

              switch (tgts) {
              | [_, ..._] => [(evs, tgts), ...acc]
              | [] =>
                failwithf(
                  f_("No possible ocamlbuild targets for object %s"),
                  cs.cs_name,
                )
              };
            }

          | [@implicit_arity] Executable(cs, bs, exec)
              when var_choose(bs.bs_build) => {
              let (evs, _, _) =
                BaseBuilt.of_executable(
                  in_build_dir_of_unix,
                  (cs, bs, exec),
                );

              let target = ext => {
                let unix_tgt =
                  OASISUnixPath.concat(
                    bs.bs_path,
                    OASISUnixPath.chop_extension(exec.exec_main_is),
                  )
                  ++ ext;

                let evs =
                  /* Fix evs, we want to use the unix_tgt, without copying */
                  List.map(
                    fun
                    | (BaseBuilt.BExec, nm, _) when nm == cs.cs_name => (
                        BaseBuilt.BExec,
                        nm,
                        [[in_build_dir_of_unix(unix_tgt)]],
                      )
                    | ev => ev,
                    evs,
                  );

                (evs, [unix_tgt]);
              };

              /* Add executable */
              let acc =
                switch (bs.bs_compiled_object) {
                | Native => [target(".native"), ...acc]
                | Best when bool_of_string(is_native()) => [
                    target(".native"),
                    ...acc,
                  ]
                | Byte
                | Best => [target(".byte"), ...acc]
                };

              acc;
            }

          | Library(_)
          | Object(_)
          | Executable(_)
          | Test(_)
          | SrcRepo(_)
          | Flag(_)
          | Doc(_) => acc,
        [],
        /* Keep the pkg.sections ordered */
        List.rev(pkg.sections),
      );

    /* Check and register built files */
    let check_and_register = ((bt, bnm, lst)) => {
      List.iter(
        fns =>
          if (!List.exists(OASISFileUtil.file_exists_case, fns)) {
            failwithf(
              fn_(
                "Expected built file %s doesn't exist.",
                "None of expected built files %s exists.",
                List.length(fns),
              ),
              String.concat(
                s_(" or "),
                List.map(Printf.sprintf("'%s'"), fns),
              ),
            );
          },
        lst,
      );
      BaseBuilt.register(~ctxt, bt, bnm, lst);
    };

    /* Run the hook */
    let cond_targets = cond_targets_hook^(cond_targets);

    /* Run a list of target... */
    run_ocamlbuild(
      ~ctxt,
      List.flatten(List.map(snd, cond_targets)) @ extra_args,
      argv,
    );
    /* ... and register events */
    List.iter(
      check_and_register,
      List.flatten(List.map(fst, cond_targets)),
    );
  };

  let clean = (~ctxt, pkg, extra_args) => {
    run_clean(~ctxt, extra_args);
    List.iter(
      fun
      | [@implicit_arity] Library(cs, _, _) =>
        BaseBuilt.unregister(~ctxt, BaseBuilt.BLib, cs.cs_name)
      | [@implicit_arity] Executable(cs, _, _) => {
          BaseBuilt.unregister(~ctxt, BaseBuilt.BExec, cs.cs_name);
          BaseBuilt.unregister(~ctxt, BaseBuilt.BExecLib, cs.cs_name);
        }
      | _ => (),
      pkg.sections,
    );
  };
};

module OCamlbuildDocPlugin = {
  /* # 22 "src/plugins/ocamlbuild/OCamlbuildDocPlugin.ml" */

  /* Create documentation using ocamlbuild .odocl files
        @author Sylvain Le Gall
     */

  open OASISTypes;
  open OASISGettext;
  open OCamlbuildCommon;

  type run_t = {
    extra_args: list(string),
    run_path: unix_filename,
  };

  let doc_build = (~ctxt, run, _, (cs, _), argv) => {
    let index_html =
      OASISUnixPath.make([
        run.run_path,
        cs.cs_name ++ ".docdir",
        "index.html",
      ]);

    let tgt_dir =
      OASISHostPath.make([
        build_dir(argv),
        OASISHostPath.of_unix(run.run_path),
        cs.cs_name ++ ".docdir",
      ]);

    run_ocamlbuild(~ctxt, [index_html, ...run.extra_args], argv);
    List.iter(
      glb =>
        switch (OASISFileUtil.glob(~ctxt, Filename.concat(tgt_dir, glb))) {
        | [_, ..._] as filenames =>
          BaseBuilt.register(~ctxt, BaseBuilt.BDoc, cs.cs_name, [filenames])
        | [] => ()
        },
      ["*.html", "*.css"],
    );
  };

  let doc_clean = (~ctxt, _, _, (cs, _), argv) => {
    run_clean(~ctxt, argv);
    BaseBuilt.unregister(~ctxt, BaseBuilt.BDoc, cs.cs_name);
  };
};

open OASISTypes;

let setup_t = {
  BaseSetup.configure: InternalConfigurePlugin.configure,
  build: OCamlbuildPlugin.build([]),
  test: [],
  doc: [],
  install: InternalInstallPlugin.install,
  uninstall: InternalInstallPlugin.uninstall,
  clean: [OCamlbuildPlugin.clean],
  clean_test: [],
  clean_doc: [],
  distclean: [],
  distclean_test: [],
  distclean_doc: [],
  package: {
    oasis_version: "0.3",
    ocaml_version: None,
    version: "0.3",
    license:
      OASISLicense.DEP5License(
        OASISLicense.DEP5Unit({
          OASISLicense.license: "BSD-3-clause",
          excption: None,
          version: OASISLicense.NoVersion,
        }),
      ),
    findlib_version: None,
    alpha_features: [],
    beta_features: [],
    name: "erm_xml",
    license_file: Some("LICENCE"),
    copyrights: ["(C) 2007-2012 Anastasia Gornostaeva"],
    maintainers: [],
    authors: ["Anastasia Gornostaeva"],
    homepage: None,
    bugreports: None,
    synopsis: "XML Stream parser",
    description: Some([OASISText.Para("XML Stream parser")]),
    tags: [],
    categories: [],
    files_ab: [],
    sections: [
      [@implicit_arity]
      Flag(
        {
          cs_name: "testing",
          cs_data: PropList.Data.create(),
          cs_plugin_data: [],
        },
        {
          flag_description: Some("Compile tests"),
          flag_default: [(OASISExpr.EBool(true), false)],
        },
      ),
      [@implicit_arity]
      Flag(
        {
          cs_name: "text",
          cs_data: PropList.Data.create(),
          cs_plugin_data: [],
        },
        {
          flag_description: Some("Compile testing with ocaml-text"),
          flag_default: [(OASISExpr.EBool(true), false)],
        },
      ),
      [@implicit_arity]
      Flag(
        {cs_name: "lwt", cs_data: PropList.Data.create(), cs_plugin_data: []},
        {
          flag_description: Some("Compile testing with lwt"),
          flag_default: [(OASISExpr.EBool(true), false)],
        },
      ),
      [@implicit_arity]
      Library(
        {
          cs_name: "erm_xml",
          cs_data: PropList.Data.create(),
          cs_plugin_data: [],
        },
        {
          bs_build: [(OASISExpr.EBool(true), true)],
          bs_install: [(OASISExpr.EBool(true), true)],
          bs_path: "src",
          bs_compiled_object: Best,
          bs_build_depends: [],
          bs_build_tools: [ExternalTool("ocamlbuild")],
          bs_interface_patterns: [
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "capitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".mli"),
              ],
              origin: "${capitalize_file module}.mli",
            },
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "uncapitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".mli"),
              ],
              origin: "${uncapitalize_file module}.mli",
            },
          ],
          bs_implementation_patterns: [
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "capitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".ml"),
              ],
              origin: "${capitalize_file module}.ml",
            },
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "uncapitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".ml"),
              ],
              origin: "${uncapitalize_file module}.ml",
            },
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "capitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".mll"),
              ],
              origin: "${capitalize_file module}.mll",
            },
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "uncapitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".mll"),
              ],
              origin: "${uncapitalize_file module}.mll",
            },
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "capitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".mly"),
              ],
              origin: "${capitalize_file module}.mly",
            },
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "uncapitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".mly"),
              ],
              origin: "${uncapitalize_file module}.mly",
            },
          ],
          bs_c_sources: [],
          bs_data_files: [],
          bs_findlib_extra_files: [],
          bs_ccopt: [(OASISExpr.EBool(true), [])],
          bs_cclib: [(OASISExpr.EBool(true), [])],
          bs_dlllib: [(OASISExpr.EBool(true), [])],
          bs_dllpath: [(OASISExpr.EBool(true), [])],
          bs_byteopt: [(OASISExpr.EBool(true), [])],
          bs_nativeopt: [(OASISExpr.EBool(true), [])],
        },
        {
          lib_modules: [
            "Xml",
            "Xmllexer_generic",
            "Xmllexer",
            "XmllexerI",
            "XmllexerI2",
            "XmllexerE",
            "Light_xml",
          ],
          lib_pack: false,
          lib_internal_modules: ["Xml_encode", "Xml_decode"],
          lib_findlib_parent: None,
          lib_findlib_name: None,
          lib_findlib_directory: None,
          lib_findlib_containers: [],
        },
      ),
      [@implicit_arity]
      Executable(
        {
          cs_name: "test1",
          cs_data: PropList.Data.create(),
          cs_plugin_data: [],
        },
        {
          bs_build: [
            (OASISExpr.EBool(true), false),
            (
              [@implicit_arity]
              OASISExpr.EAnd(
                OASISExpr.EFlag("testing"),
                OASISExpr.EFlag("text"),
              ),
              true,
            ),
          ],
          bs_install: [(OASISExpr.EBool(true), false)],
          bs_path: "tests",
          bs_compiled_object: Byte,
          bs_build_depends: [InternalLibrary("erm_xml")],
          bs_build_tools: [ExternalTool("ocamlbuild")],
          bs_interface_patterns: [
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "capitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".mli"),
              ],
              origin: "${capitalize_file module}.mli",
            },
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "uncapitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".mli"),
              ],
              origin: "${uncapitalize_file module}.mli",
            },
          ],
          bs_implementation_patterns: [
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "capitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".ml"),
              ],
              origin: "${capitalize_file module}.ml",
            },
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "uncapitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".ml"),
              ],
              origin: "${uncapitalize_file module}.ml",
            },
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "capitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".mll"),
              ],
              origin: "${capitalize_file module}.mll",
            },
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "uncapitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".mll"),
              ],
              origin: "${uncapitalize_file module}.mll",
            },
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "capitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".mly"),
              ],
              origin: "${capitalize_file module}.mly",
            },
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "uncapitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".mly"),
              ],
              origin: "${uncapitalize_file module}.mly",
            },
          ],
          bs_c_sources: [],
          bs_data_files: [],
          bs_findlib_extra_files: [],
          bs_ccopt: [(OASISExpr.EBool(true), [])],
          bs_cclib: [(OASISExpr.EBool(true), [])],
          bs_dlllib: [(OASISExpr.EBool(true), [])],
          bs_dllpath: [(OASISExpr.EBool(true), [])],
          bs_byteopt: [(OASISExpr.EBool(true), [])],
          bs_nativeopt: [(OASISExpr.EBool(true), [])],
        },
        {exec_custom: false, exec_main_is: "test1.ml"},
      ),
      [@implicit_arity]
      Executable(
        {
          cs_name: "test2",
          cs_data: PropList.Data.create(),
          cs_plugin_data: [],
        },
        {
          bs_build: [
            (OASISExpr.EBool(true), false),
            (OASISExpr.EFlag("testing"), true),
          ],
          bs_install: [(OASISExpr.EBool(true), false)],
          bs_path: "tests",
          bs_compiled_object: Byte,
          bs_build_depends: [
            InternalLibrary("erm_xml"),
            [@implicit_arity] FindlibPackage("text", None),
          ],
          bs_build_tools: [ExternalTool("ocamlbuild")],
          bs_interface_patterns: [
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "capitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".mli"),
              ],
              origin: "${capitalize_file module}.mli",
            },
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "uncapitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".mli"),
              ],
              origin: "${uncapitalize_file module}.mli",
            },
          ],
          bs_implementation_patterns: [
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "capitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".ml"),
              ],
              origin: "${capitalize_file module}.ml",
            },
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "uncapitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".ml"),
              ],
              origin: "${uncapitalize_file module}.ml",
            },
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "capitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".mll"),
              ],
              origin: "${capitalize_file module}.mll",
            },
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "uncapitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".mll"),
              ],
              origin: "${uncapitalize_file module}.mll",
            },
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "capitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".mly"),
              ],
              origin: "${capitalize_file module}.mly",
            },
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "uncapitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".mly"),
              ],
              origin: "${uncapitalize_file module}.mly",
            },
          ],
          bs_c_sources: [],
          bs_data_files: [],
          bs_findlib_extra_files: [],
          bs_ccopt: [(OASISExpr.EBool(true), [])],
          bs_cclib: [(OASISExpr.EBool(true), [])],
          bs_dlllib: [(OASISExpr.EBool(true), [])],
          bs_dllpath: [(OASISExpr.EBool(true), [])],
          bs_byteopt: [(OASISExpr.EBool(true), [])],
          bs_nativeopt: [(OASISExpr.EBool(true), [])],
        },
        {exec_custom: false, exec_main_is: "test2.ml"},
      ),
      [@implicit_arity]
      Executable(
        {
          cs_name: "test3",
          cs_data: PropList.Data.create(),
          cs_plugin_data: [],
        },
        {
          bs_build: [
            (OASISExpr.EBool(true), false),
            (
              [@implicit_arity]
              OASISExpr.EAnd(
                OASISExpr.EFlag("testing"),
                OASISExpr.EFlag("lwt"),
              ),
              true,
            ),
          ],
          bs_install: [(OASISExpr.EBool(true), false)],
          bs_path: "tests",
          bs_compiled_object: Byte,
          bs_build_depends: [
            InternalLibrary("erm_xml"),
            [@implicit_arity] FindlibPackage("lwt", None),
            [@implicit_arity] FindlibPackage("lwt.unix", None),
          ],
          bs_build_tools: [ExternalTool("ocamlbuild")],
          bs_interface_patterns: [
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "capitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".mli"),
              ],
              origin: "${capitalize_file module}.mli",
            },
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "uncapitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".mli"),
              ],
              origin: "${uncapitalize_file module}.mli",
            },
          ],
          bs_implementation_patterns: [
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "capitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".ml"),
              ],
              origin: "${capitalize_file module}.ml",
            },
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "uncapitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".ml"),
              ],
              origin: "${uncapitalize_file module}.ml",
            },
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "capitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".mll"),
              ],
              origin: "${capitalize_file module}.mll",
            },
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "uncapitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".mll"),
              ],
              origin: "${uncapitalize_file module}.mll",
            },
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "capitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".mly"),
              ],
              origin: "${capitalize_file module}.mly",
            },
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "uncapitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".mly"),
              ],
              origin: "${uncapitalize_file module}.mly",
            },
          ],
          bs_c_sources: [],
          bs_data_files: [],
          bs_findlib_extra_files: [],
          bs_ccopt: [(OASISExpr.EBool(true), [])],
          bs_cclib: [(OASISExpr.EBool(true), [])],
          bs_dlllib: [(OASISExpr.EBool(true), [])],
          bs_dllpath: [(OASISExpr.EBool(true), [])],
          bs_byteopt: [(OASISExpr.EBool(true), [])],
          bs_nativeopt: [(OASISExpr.EBool(true), [])],
        },
        {exec_custom: false, exec_main_is: "test3.ml"},
      ),
      [@implicit_arity]
      Executable(
        {
          cs_name: "light_test",
          cs_data: PropList.Data.create(),
          cs_plugin_data: [],
        },
        {
          bs_build: [
            (OASISExpr.EBool(true), false),
            (OASISExpr.EFlag("testing"), true),
          ],
          bs_install: [(OASISExpr.EBool(true), false)],
          bs_path: "tests",
          bs_compiled_object: Byte,
          bs_build_depends: [InternalLibrary("erm_xml")],
          bs_build_tools: [ExternalTool("ocamlbuild")],
          bs_interface_patterns: [
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "capitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".mli"),
              ],
              origin: "${capitalize_file module}.mli",
            },
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "uncapitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".mli"),
              ],
              origin: "${uncapitalize_file module}.mli",
            },
          ],
          bs_implementation_patterns: [
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "capitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".ml"),
              ],
              origin: "${capitalize_file module}.ml",
            },
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "uncapitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".ml"),
              ],
              origin: "${uncapitalize_file module}.ml",
            },
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "capitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".mll"),
              ],
              origin: "${capitalize_file module}.mll",
            },
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "uncapitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".mll"),
              ],
              origin: "${uncapitalize_file module}.mll",
            },
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "capitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".mly"),
              ],
              origin: "${capitalize_file module}.mly",
            },
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "uncapitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".mly"),
              ],
              origin: "${uncapitalize_file module}.mly",
            },
          ],
          bs_c_sources: [],
          bs_data_files: [],
          bs_findlib_extra_files: [],
          bs_ccopt: [(OASISExpr.EBool(true), [])],
          bs_cclib: [(OASISExpr.EBool(true), [])],
          bs_dlllib: [(OASISExpr.EBool(true), [])],
          bs_dllpath: [(OASISExpr.EBool(true), [])],
          bs_byteopt: [(OASISExpr.EBool(true), [])],
          bs_nativeopt: [(OASISExpr.EBool(true), [])],
        },
        {exec_custom: false, exec_main_is: "light_test.ml"},
      ),
      [@implicit_arity]
      Executable(
        {
          cs_name: "test",
          cs_data: PropList.Data.create(),
          cs_plugin_data: [],
        },
        {
          bs_build: [(OASISExpr.EBool(true), true)],
          bs_install: [(OASISExpr.EBool(true), false)],
          bs_path: "tests",
          bs_compiled_object: Byte,
          bs_build_depends: [InternalLibrary("erm_xml")],
          bs_build_tools: [ExternalTool("ocamlbuild")],
          bs_interface_patterns: [
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "capitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".mli"),
              ],
              origin: "${capitalize_file module}.mli",
            },
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "uncapitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".mli"),
              ],
              origin: "${uncapitalize_file module}.mli",
            },
          ],
          bs_implementation_patterns: [
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "capitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".ml"),
              ],
              origin: "${capitalize_file module}.ml",
            },
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "uncapitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".ml"),
              ],
              origin: "${uncapitalize_file module}.ml",
            },
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "capitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".mll"),
              ],
              origin: "${capitalize_file module}.mll",
            },
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "uncapitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".mll"),
              ],
              origin: "${uncapitalize_file module}.mll",
            },
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "capitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".mly"),
              ],
              origin: "${capitalize_file module}.mly",
            },
            {
              OASISSourcePatterns.Templater.atoms: [
                OASISSourcePatterns.Templater.Text(""),
                OASISSourcePatterns.Templater.Expr(
                  [@implicit_arity]
                  OASISSourcePatterns.Templater.Call(
                    "uncapitalize_file",
                    OASISSourcePatterns.Templater.Ident("module"),
                  ),
                ),
                OASISSourcePatterns.Templater.Text(".mly"),
              ],
              origin: "${uncapitalize_file module}.mly",
            },
          ],
          bs_c_sources: [],
          bs_data_files: [],
          bs_findlib_extra_files: [],
          bs_ccopt: [(OASISExpr.EBool(true), [])],
          bs_cclib: [(OASISExpr.EBool(true), [])],
          bs_dlllib: [(OASISExpr.EBool(true), [])],
          bs_dllpath: [(OASISExpr.EBool(true), [])],
          bs_byteopt: [(OASISExpr.EBool(true), [])],
          bs_nativeopt: [(OASISExpr.EBool(true), [])],
        },
        {exec_custom: false, exec_main_is: "test.ml"},
      ),
      [@implicit_arity]
      SrcRepo(
        {
          cs_name: "github",
          cs_data: PropList.Data.create(),
          cs_plugin_data: [],
        },
        {
          src_repo_type: Git,
          src_repo_location: "git://github.com/ermine/xml.git",
          src_repo_browser: Some("https://github.com/ermine/xml"),
          src_repo_module: None,
          src_repo_branch: None,
          src_repo_tag: None,
          src_repo_subdir: None,
        },
      ),
    ],
    disable_oasis_section: [],
    conf_type: (`Configure, "internal", Some("0.4")),
    conf_custom: {
      pre_command: [(OASISExpr.EBool(true), None)],
      post_command: [(OASISExpr.EBool(true), None)],
    },
    build_type: (`Build, "ocamlbuild", Some("0.4")),
    build_custom: {
      pre_command: [(OASISExpr.EBool(true), None)],
      post_command: [(OASISExpr.EBool(true), None)],
    },
    install_type: (`Install, "internal", Some("0.4")),
    install_custom: {
      pre_command: [(OASISExpr.EBool(true), None)],
      post_command: [(OASISExpr.EBool(true), None)],
    },
    uninstall_custom: {
      pre_command: [(OASISExpr.EBool(true), None)],
      post_command: [(OASISExpr.EBool(true), None)],
    },
    clean_custom: {
      pre_command: [(OASISExpr.EBool(true), None)],
      post_command: [(OASISExpr.EBool(true), None)],
    },
    distclean_custom: {
      pre_command: [(OASISExpr.EBool(true), None)],
      post_command: [(OASISExpr.EBool(true), None)],
    },
    plugins: [
      (`Extra, "DevFiles", Some("0.2")),
      (`Extra, "META", Some("0.2")),
    ],
    schema_data: PropList.Data.create(),
    plugin_data: [],
  },
  oasis_fn: Some("_oasis"),
  oasis_version: "0.4.10",
  oasis_digest: Some("!\024\rs"),
  oasis_exec: None,
  oasis_setup_args: [],
  setup_update: false,
};

let setup = () => BaseSetup.setup(setup_t);

let setup_t = BaseCompat.Compat_0_3.adapt_setup_t(setup_t);
open BaseCompat.Compat_0_3;
/* OASIS_STOP */
let () = setup();
